{
  "id": "CVE-2025-22003",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-04-03T08:15:15.840",
  "lastModified": "2025-04-07T14:18:34.453",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: ucan: fix out of bound read in strscpy() source\n\nCommit 7fdaf8966aae (\"can: ucan: use strscpy() to instead of strncpy()\")\nunintentionally introduced a one byte out of bound read on strscpy()'s\nsource argument (which is kind of ironic knowing that strscpy() is meant\nto be a more secure alternative :)).\n\nLet's consider below buffers:\n\n  dest[len + 1]; /* will be NUL terminated */\n  src[len]; /* may not be NUL terminated */\n\nWhen doing:\n\n  strncpy(dest, src, len);\n  dest[len] = '\\0';\n\nstrncpy() will read up to len bytes from src.\n\nOn the other hand:\n\n  strscpy(dest, src, len + 1);\n\nwill read up to len + 1 bytes from src, that is to say, an out of bound\nread of one byte will occur on src if it is not NUL terminated. Note\nthat the src[len] byte is never copied, but strscpy() still needs to\nread it to check whether a truncation occurred or not.\n\nThis exact pattern happened in ucan.\n\nThe root cause is that the source is not NUL terminated. Instead of\ndoing a copy in a local buffer, directly NUL terminate it as soon as\nusb_control_msg() returns. With this, the local firmware_str[] variable\ncan be removed.\n\nOn top of this do a couple refactors:\n\n  - ucan_ctl_payload->raw is only used for the firmware string, so\n    rename it to ucan_ctl_payload->fw_str and change its type from u8 to\n    char.\n\n  - ucan_device_request_in() is only used to retrieve the firmware\n    string, so rename it to ucan_get_fw_str() and refactor it to make it\n    directly handle all the string termination logic."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: can: ucan: fix out of bound read in strscpy() source Commit 7fdaf8966aae (\"can: ucan: use strscpy() to instead of strncpy()\") introdujo involuntariamente una lectura fuera de los l\u00edmite de un byte en el argumento source de strscpy() (lo cual es un poco ir\u00f3nico sabiendo que strscpy() est\u00e1 destinado a ser una alternativa m\u00e1s segura :)). Consideremos los siguientes b\u00faferes: dest[len + 1]; /* terminar\u00e1 en NUL */ src[len]; /* puede que no termine en NUL */ Al hacer: strncpy(dest, src, len); dest[len] = '\\0'; strncpy() leer\u00e1 hasta len bytes desde src. Por otro lado: strscpy(dest, src, len + 1); Leer\u00e1 hasta len + 1 bytes de src; es decir, se producir\u00e1 una lectura fuera de los l\u00edmites de un byte en src si no termina en NUL. Tenga en cuenta que el byte src[len] nunca se copia, pero strscpy() a\u00fan necesita leerlo para verificar si se produjo un truncamiento. Este mismo patr\u00f3n ocurri\u00f3 en ucan. La causa ra\u00edz es que el origen no termina en NUL. En lugar de hacer una copia en un b\u00fafer local, termine directamente en NUL tan pronto como usb_control_msg() regrese. Con esto, se puede eliminar la variable local firmware_str[]. Adem\u00e1s, realice un par de refactorizaciones: - ucan_ctl_payload-&gt;raw solo se usa para la cadena de firmware, as\u00ed que ren\u00f3mbrelo a ucan_ctl_payload-&gt;fw_str y cambie su tipo de u8 a char. - ucan_device_request_in() solo se utiliza para recuperar la cadena de firmware, as\u00ed que c\u00e1mbiele el nombre a ucan_get_fw_str() y refactor\u00edcelo para que gestione directamente toda la l\u00f3gica de terminaci\u00f3n de la cadena."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/1d22a122ffb116c3cf78053e812b8b21f8852ee9",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8cec9e314d3360fc1d8346297c41a6ee45cb45a9",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a4994161a61bc8fd71d105c579d847cefee99262",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/cc29775a8a72d7f3b56cc026796ad99bd65804a7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}