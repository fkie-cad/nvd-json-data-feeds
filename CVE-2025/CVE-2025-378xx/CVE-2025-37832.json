{
  "id": "CVE-2025-37832",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-05-08T07:15:54.437",
  "lastModified": "2025-05-08T14:39:09.683",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq: sun50i: prevent out-of-bounds access\n\nA KASAN enabled kernel reports an out-of-bounds access when handling the\nnvmem cell in the sun50i cpufreq driver:\n==================================================================\nBUG: KASAN: slab-out-of-bounds in sun50i_cpufreq_nvmem_probe+0x180/0x3d4\nRead of size 4 at addr ffff000006bf31e0 by task kworker/u16:1/38\n\nThis is because the DT specifies the nvmem cell as covering only two\nbytes, but we use a u32 pointer to read the value. DTs for other SoCs\nindeed specify 4 bytes, so we cannot just shorten the variable to a u16.\n\nFortunately nvmem_cell_read() allows to return the length of the nvmem\ncell, in bytes, so we can use that information to only access the valid\nportion of the data.\nTo cover multiple cell sizes, use memcpy() to copy the information into a\nzeroed u32 buffer, then also make sure we always read the data in little\nendian fashion, as this is how the data is stored in the SID efuses."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: cpufreq: sun50i: evitar acceso fuera de los l\u00edmites Un kernel habilitado para KASAN informa un acceso fuera de los l\u00edmites al manejar la celda nvmem en el controlador cpufreq sun50i: ======================================================================== ERROR: KASAN: slab-out-of-bounds en sun50i_cpufreq_nvmem_probe+0x180/0x3d4 Lectura de tama\u00f1o 4 en la direcci\u00f3n ffff000006bf31e0 por la tarea kworker/u16:1/38 Esto se debe a que el DT especifica que la celda nvmem cubre solo dos bytes, pero usamos u32 Puntero para leer el valor. Los DT de otros SoCs especifican 4 bytes, por lo que no podemos acortar la variable a u16. Afortunadamente, nvmem_cell_read() permite devolver la longitud de la celda nvmem, en bytes, lo que nos permite usar esa informaci\u00f3n para acceder \u00fanicamente a la parte v\u00e1lida de los datos. Para abarcar varios tama\u00f1os de celda, use memcpy() para copiar la informaci\u00f3n a un b\u00fafer u32 con ceros. Aseg\u00farese tambi\u00e9n de leer siempre los datos en formato little endian, ya que as\u00ed es como se almacenan en los efuses SID."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/14c8a418159e541d70dbf8fc71225d1623beaf0f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/40bf7f560ca4c2468d518cebf14561bc864f58f8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/dba5a1f963cf781c0b60f4b7f07465a6c687c27e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}