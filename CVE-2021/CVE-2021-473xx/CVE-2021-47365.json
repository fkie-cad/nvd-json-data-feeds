{
  "id": "CVE-2021-47365",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-21T15:15:22.563",
  "lastModified": "2024-05-21T16:54:26.047",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nafs: Fix page leak\n\nThere's a loop in afs_extend_writeback() that adds extra pages to a write\nwe want to make to improve the efficiency of the writeback by making it\nlarger.  This loop stops, however, if we hit a page we can't write back\nfrom immediately, but it doesn't get rid of the page ref we speculatively\nacquired.\n\nThis was caused by the removal of the cleanup loop when the code switched\nfrom using find_get_pages_contig() to xarray scanning as the latter only\ngets a single page at a time, not a batch.\n\nFix this by putting the page on a ref on an early break from the loop.\nUnfortunately, we can't just add that page to the pagevec we're employing\nas we'll go through that and add those pages to the RPC call.\n\nThis was found by the generic/074 test.  It leaks ~4GiB of RAM each time it\nis run - which can be observed with \"top\"."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: afs: Reparar p\u00e9rdida de p\u00e1gina. Hay un bucle en afs_extend_writeback() que agrega p\u00e1ginas adicionales a una escritura que queremos realizar para mejorar la eficiencia de la escritura diferida haci\u00e9ndola m\u00e1s grande. Sin embargo, este bucle se detiene si llegamos a una p\u00e1gina desde la que no podemos escribir de inmediato, pero no elimina la referencia de p\u00e1gina que adquirimos especulativamente. Esto se debi\u00f3 a la eliminaci\u00f3n del bucle de limpieza cuando el c\u00f3digo pas\u00f3 de usar find_get_pages_contig() a escanear xarray, ya que este \u00faltimo solo obtiene una p\u00e1gina a la vez, no un lote. Solucione este problema poniendo la p\u00e1gina en un \u00e1rbitro en un descanso temprano del bucle. Desafortunadamente, no podemos simplemente agregar esa p\u00e1gina al pagevec que estamos empleando, ya que revisaremos eso y agregaremos esas p\u00e1ginas a la llamada RPC. Esto se encontr\u00f3 mediante la prueba gen\u00e9rica/074. Pierde ~4GiB de RAM cada vez que se ejecuta, lo que se puede observar con \"TOP\"."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/581b2027af0018944ba301d68e7af45c6d1128b5",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d130b5fdd42254d92948d06347940276140c927e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}