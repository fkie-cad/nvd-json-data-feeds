{
  "id": "CVE-2021-47369",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-21T15:15:22.853",
  "lastModified": "2024-05-21T16:54:26.047",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/qeth: fix NULL deref in qeth_clear_working_pool_list()\n\nWhen qeth_set_online() calls qeth_clear_working_pool_list() to roll\nback after an error exit from qeth_hardsetup_card(), we are at risk of\naccessing card->qdio.in_q before it was allocated by\nqeth_alloc_qdio_queues() via qeth_mpc_initialize().\n\nqeth_clear_working_pool_list() then dereferences NULL, and by writing to\nqueue->bufs[i].pool_entry scribbles all over the CPU's lowcore.\nResulting in a crash when those lowcore areas are used next (eg. on\nthe next machine-check interrupt).\n\nSuch a scenario would typically happen when the device is first set\nonline and its queues aren't allocated yet. An early IO error or certain\nmisconfigs (eg. mismatched transport mode, bad portno) then cause us to\nerror out from qeth_hardsetup_card() with card->qdio.in_q still being\nNULL.\n\nFix it by checking the pointer for NULL before accessing it.\n\nNote that we also have (rare) paths inside qeth_mpc_initialize() where\na configuration change can cause us to free the existing queues,\nexpecting that subsequent code will allocate them again. If we then\nerror out before that re-allocation happens, the same bug occurs.\n\nRoot-caused-by: Heiko Carstens <hca@linux.ibm.com>"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: s390/qeth: corrige NULL deref en qeth_clear_working_pool_list(). Cuando qeth_set_online() llama a qeth_clear_working_pool_list() para retroceder despu\u00e9s de una salida de error de qeth_hardsetup_card(), corremos el riesgo de acceder a la tarjeta -&gt;qdio.in_q antes de que qeth_alloc_qdio_queues() lo asignara mediante qeth_mpc_initialize(). qeth_clear_working_pool_list() luego elimina la referencia a NULL y, al escribir en queue-&gt;bufs[i].pool_entry garabatea por todo el n\u00facleo bajo de la CPU. Lo que resulta en un bloqueo cuando esas \u00e1reas de n\u00facleo bajo se usan a continuaci\u00f3n (por ejemplo, en la siguiente interrupci\u00f3n de verificaci\u00f3n de la m\u00e1quina). Este escenario suele ocurrir cuando el dispositivo se configura en l\u00ednea por primera vez y sus colas a\u00fan no est\u00e1n asignadas. Un error de IO temprano o ciertas configuraciones err\u00f3neas (por ejemplo, modo de transporte no coincidente, n\u00famero de puerto incorrecto) hacen que salgamos del error qeth_hardsetup_card() con card-&gt;qdio.in_q todav\u00eda siendo NULL. Solucionarlo comprobando que el puntero sea NULL antes de acceder a \u00e9l. Tenga en cuenta que tambi\u00e9n tenemos rutas (raras) dentro de qeth_mpc_initialize() donde un cambio de configuraci\u00f3n puede hacer que liberemos las colas existentes, esperando que el c\u00f3digo posterior las asigne nuevamente. Si luego cometemos un error antes de que ocurra la reasignaci\u00f3n, ocurre el mismo error. Analizado por: Heiko Carstens "
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/248f064af222a1f97ee02c84a98013dfbccad386",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9b00fb12cdc9d8d1c3ffe82a78e74738127803fc",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/db94f89e1dadf693c15c2d60de0c34777cea5779",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}