{
  "id": "CVE-2021-47366",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-21T15:15:22.633",
  "lastModified": "2024-05-21T16:54:26.047",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nafs: Fix corruption in reads at fpos 2G-4G from an OpenAFS server\n\nAFS-3 has two data fetch RPC variants, FS.FetchData and FS.FetchData64, and\nLinux's afs client switches between them when talking to a non-YFS server\nif the read size, the file position or the sum of the two have the upper 32\nbits set of the 64-bit value.\n\nThis is a problem, however, since the file position and length fields of\nFS.FetchData are *signed* 32-bit values.\n\nFix this by capturing the capability bits obtained from the fileserver when\nit's sent an FS.GetCapabilities RPC, rather than just discarding them, and\nthen picking out the VICED_CAPABILITY_64BITFILES flag.  This can then be\nused to decide whether to use FS.FetchData or FS.FetchData64 - and also\nFS.StoreData or FS.StoreData64 - rather than using upper_32_bits() to\nswitch on the parameter values.\n\nThis capabilities flag could also be used to limit the maximum size of the\nfile, but all servers must be checked for that.\n\nNote that the issue does not exist with FS.StoreData - that uses *unsigned*\n32-bit values.  It's also not a problem with Auristor servers as its\nYFS.FetchData64 op uses unsigned 64-bit values.\n\nThis can be tested by cloning a git repo through an OpenAFS client to an\nOpenAFS server and then doing \"git status\" on it from a Linux afs\nclient[1].  Provided the clone has a pack file that's in the 2G-4G range,\nthe git status will show errors like:\n\n\terror: packfile .git/objects/pack/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack does not match index\n\terror: packfile .git/objects/pack/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack does not match index\n\nThis can be observed in the server's FileLog with something like the\nfollowing appearing:\n\nSun Aug 29 19:31:39 2021 SRXAFS_FetchData, Fid = 2303380852.491776.3263114, Host 192.168.11.201:7001, Id 1001\nSun Aug 29 19:31:39 2021 CheckRights: len=0, for host=192.168.11.201:7001\nSun Aug 29 19:31:39 2021 FetchData_RXStyle: Pos 18446744071815340032, Len 3154\nSun Aug 29 19:31:39 2021 FetchData_RXStyle: file size 2400758866\n...\nSun Aug 29 19:31:40 2021 SRXAFS_FetchData returns 5\n\nNote the file position of 18446744071815340032.  This is the requested file\nposition sign-extended."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: afs: corrige la corrupci\u00f3n en las lecturas en fpos 2G-4G desde un servidor OpenAFS. AFS-3 tiene dos variantes RPC de recuperaci\u00f3n de datos, FS.FetchData y FS.FetchData64, y conmutadores de cliente afs de Linux. entre ellos cuando se habla con un servidor que no es YFS si el tama\u00f1o de lectura, la posici\u00f3n del archivo o la suma de los dos tienen los 32 bits superiores establecidos del valor de 64 bits. Sin embargo, esto es un problema, ya que los campos de posici\u00f3n y longitud del archivo de FS.FetchData son valores *firmados* de 32 bits. Solucione este problema capturando los bits de capacidad obtenidos del servidor de archivos cuando se env\u00eda un RPC FS.GetCapabilities, en lugar de simplemente descartarlos, y luego seleccionando el indicador VICED_CAPABILITY_64BITFILES. Esto luego se puede usar para decidir si usar FS.FetchData o FS.FetchData64, y tambi\u00e9n FS.StoreData o FS.StoreData64, en lugar de usar Upper_32_bits() para activar los valores de los par\u00e1metros. Este indicador de capacidades tambi\u00e9n podr\u00eda usarse para limitar el tama\u00f1o m\u00e1ximo del archivo, pero se deben verificar todos los servidores para eso. Tenga en cuenta que el problema no existe con FS.StoreData, que utiliza valores de 32 bits *sin firmar*. Tampoco es un problema con los servidores Auristor ya que su operaci\u00f3n YFS.FetchData64 utiliza valores de 64 bits sin firmar. Esto se puede probar clonando un repositorio de git a trav\u00e9s de un cliente OpenAFS en un servidor OpenAFS y luego ejecutando el \"estado de git\" desde un cliente afs de Linux[1]. Siempre que el clon tenga un archivo de paquete que est\u00e9 en el rango 2G-4G, el estado de git mostrar\u00e1 errores como: error: packfile .git/objects/pack/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack no coincide con el \u00edndice error: packfile .git/objects/ pack/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack no coincide con el \u00edndice. Esto se puede observar en el FileLog del servidor y aparece algo como lo siguiente: Dom 29 de agosto 19:31:39 2021 SRXAFS_FetchData, Fid = 2303380852.491776.3263114 , Anfitri\u00f3n 192.168.11.201:7001, Id 1001 dom 29 de agosto 19:31:39 2021 CheckRights: len=0, for host=192.168.11.201:7001 dom 29 de agosto 19:31:39 2021 FetchData_RXStyle: Pos 18446744071815340032, Len 3154 dom 29 de agosto 19:3 1:39 2021 FetchData_RXStyle: tama\u00f1o de archivo 2400758866 ... domingo 29 de agosto 19:31:40 2021 SRXAFS_FetchData devuelve 5 Tenga en cuenta la posici\u00f3n del archivo de 18446744071815340032. Esta es la posici\u00f3n del archivo solicitada con signo extendido."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/b537a3c21775075395af475dcc6ef212fcf29db8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e66fc460d6dcf85cf12288e133a081205aebcd97",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}