{
  "id": "CVE-2022-48950",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-10-21T20:15:06.440",
  "lastModified": "2024-10-23T15:13:25.583",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Fix perf_pending_task() UaF\n\nPer syzbot it is possible for perf_pending_task() to run after the\nevent is free()'d. There are two related but distinct cases:\n\n - the task_work was already queued before destroying the event;\n - destroying the event itself queues the task_work.\n\nThe first cannot be solved using task_work_cancel() since\nperf_release() itself might be called from a task_work (____fput),\nwhich means the current->task_works list is already empty and\ntask_work_cancel() won't be able to find the perf_pending_task()\nentry.\n\nThe simplest alternative is extending the perf_event lifetime to cover\nthe task_work.\n\nThe second is just silly, queueing a task_work while you know the\nevent is going away makes no sense and is easily avoided by\nre-arranging how the event is marked STATE_DEAD and ensuring it goes\nthrough STATE_OFF on the way down."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: perf: Fix perf_pending_task() UaF Por syzbot es posible que perf_pending_task() se ejecute despu\u00e9s de que el evento sea free(). Hay dos casos relacionados pero distintos: - el task_work ya estaba en cola antes de destruir el evento; - destruir el evento en s\u00ed mismo pone en cola el task_work. El primero no se puede resolver usando task_work_cancel() ya que perf_release() en s\u00ed mismo podr\u00eda ser llamado desde un task_work (____fput), lo que significa que la lista current-&gt;task_works ya est\u00e1 vac\u00eda y task_work_cancel() no podr\u00e1 encontrar la entrada perf_pending_task(). La alternativa m\u00e1s simple es extender la duraci\u00f3n de perf_event para cubrir el task_work. El segundo es simplemente una tonter\u00eda, poner en cola una tarea_trabajo mientras sabes que el evento va a desaparecer no tiene sentido y se evita f\u00e1cilmente reorganizando c\u00f3mo se marca el evento como STATE_DEAD y asegur\u00e1ndose de que pase por STATE_OFF en el camino hacia abajo."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/517e6a301f34613bff24a8e35b5455884f2d83d8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/78e1317a174edbfd1182599bf76c092a2877672c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8bffa95ac19ff27c8261904f89d36c7fcf215d59",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}