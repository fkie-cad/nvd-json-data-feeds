{
  "id": "CVE-2022-48998",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-10-21T20:15:11.570",
  "lastModified": "2024-11-07T17:08:38.677",
  "vulnStatus": "Analyzed",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/bpf/32: Fix Oops on tail call tests\n\ntest_bpf tail call tests end up as:\n\n  test_bpf: #0 Tail call leaf jited:1 85 PASS\n  test_bpf: #1 Tail call 2 jited:1 111 PASS\n  test_bpf: #2 Tail call 3 jited:1 145 PASS\n  test_bpf: #3 Tail call 4 jited:1 170 PASS\n  test_bpf: #4 Tail call load/store leaf jited:1 190 PASS\n  test_bpf: #5 Tail call load/store jited:1\n  BUG: Unable to handle kernel data access on write at 0xf1b4e000\n  Faulting instruction address: 0xbe86b710\n  Oops: Kernel access of bad area, sig: 11 [#1]\n  BE PAGE_SIZE=4K MMU=Hash PowerMac\n  Modules linked in: test_bpf(+)\n  CPU: 0 PID: 97 Comm: insmod Not tainted 6.1.0-rc4+ #195\n  Hardware name: PowerMac3,1 750CL 0x87210 PowerMac\n  NIP:  be86b710 LR: be857e88 CTR: be86b704\n  REGS: f1b4df20 TRAP: 0300   Not tainted  (6.1.0-rc4+)\n  MSR:  00009032 <EE,ME,IR,DR,RI>  CR: 28008242  XER: 00000000\n  DAR: f1b4e000 DSISR: 42000000\n  GPR00: 00000001 f1b4dfe0 c11d2280 00000000 00000000 00000000 00000002 00000000\n  GPR08: f1b4e000 be86b704 f1b4e000 00000000 00000000 100d816a f2440000 fe73baa8\n  GPR16: f2458000 00000000 c1941ae4 f1fe2248 00000045 c0de0000 f2458030 00000000\n  GPR24: 000003e8 0000000f f2458000 f1b4dc90 3e584b46 00000000 f24466a0 c1941a00\n  NIP [be86b710] 0xbe86b710\n  LR [be857e88] __run_one+0xec/0x264 [test_bpf]\n  Call Trace:\n  [f1b4dfe0] [00000002] 0x2 (unreliable)\n  Instruction dump:\n  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n  ---[ end trace 0000000000000000 ]---\n\nThis is a tentative to write above the stack. The problem is encoutered\nwith tests added by commit 38608ee7b690 (\"bpf, tests: Add load store\ntest case for tail call\")\n\nThis happens because tail call is done to a BPF prog with a different\nstack_depth. At the time being, the stack is kept as is when the caller\ntail calls its callee. But at exit, the callee restores the stack based\non its own properties. Therefore here, at each run, r1 is erroneously\nincreased by 32 - 16 = 16 bytes.\n\nThis was done that way in order to pass the tail call count from caller\nto callee through the stack. As powerpc32 doesn't have a red zone in\nthe stack, it was necessary the maintain the stack as is for the tail\ncall. But it was not anticipated that the BPF frame size could be\ndifferent.\n\nLet's take a new approach. Use register r4 to carry the tail call count\nduring the tail call, and save it into the stack at function entry if\nrequired. This means the input parameter must be in r3, which is more\ncorrect as it is a 32 bits parameter, then tail call better match with\nnormal BPF function entry, the down side being that we move that input\nparameter back and forth between r3 and r4. That can be optimised later.\n\nDoing that also has the advantage of maximising the common parts between\ntail calls and a normal function exit.\n\nWith the fix, tail call tests are now successfull:\n\n  test_bpf: #0 Tail call leaf jited:1 53 PASS\n  test_bpf: #1 Tail call 2 jited:1 115 PASS\n  test_bpf: #2 Tail call 3 jited:1 154 PASS\n  test_bpf: #3 Tail call 4 jited:1 165 PASS\n  test_bpf: #4 Tail call load/store leaf jited:1 101 PASS\n  test_bpf: #5 Tail call load/store jited:1 141 PASS\n  test_bpf: #6 Tail call error path, max count reached jited:1 994 PASS\n  test_bpf: #7 Tail call count preserved across function calls jited:1 140975 PASS\n  test_bpf: #8 Tail call error path, NULL target jited:1 110 PASS\n  test_bpf: #9 Tail call error path, index out of range jited:1 69 PASS\n  test_bpf: test_tail_calls: Summary: 10 PASSED, 0 FAILED, [10/10 JIT'ed]"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: powerpc/bpf/32: Se ha corregido el error Oops en las pruebas de llamadas de cola. Las pruebas de llamadas de cola test_bpf terminan como: test_bpf: #0 Tail call leaf jited:1 85 PASS test_bpf: #1 Tail call 2 jited:1 111 PASS test_bpf: #2 Tail call 3 jited:1 145 PASS test_bpf: #3 Tail call 4 jited:1 170 PASS test_bpf: #4 Tail call load/store leaf jited:1 190 PASS test_bpf: #5 Tail call load/store jited:1 ERROR: No se puede manejar el acceso a los datos del kernel en escritura en 0xf1b4e000 Direcci\u00f3n de instrucci\u00f3n err\u00f3nea: 0xbe86b710 Oops: Acceso al kernel de un \u00e1rea defectuosa, firma: 11 [#1] BE PAGE_SIZE=4K MMU=Hash M\u00f3dulos PowerMac vinculados en: test_bpf(+) CPU: 0 PID: 97 Comm: insmod No contaminado 6.1.0-rc4+ #195 Nombre del hardware: PowerMac3,1 750CL 0x87210 PowerMac NIP: be86b710 LR: be857e88 CTR: be86b704 REGS: f1b4df20 TRAP: 0300 No contaminado (6.1.0-rc4+) MSR: 00009032  CR: 28008242 XER: 00000000 DAR: f1b4e000 DSISR: 42000000 GPR00: 00000001 f1b4dfe0 c11d2280 00000000 00000000 00000000 00000002 00000000 GPR08: f1b4e000 be86b704 f1b4e000 00000000 00000000 100d816a f2440000 fe73baa8 GPR16: f2458000 00000000 c1941ae4 f1fe2248 00000045 c0de0000 f2458030 00000000 GPR24: 000003e8 0000000f f2458000 f1b4dc90 3e584b46 00000000 f24466a0 c1941a00 NIP [be86b710] 0xbe86b710 LR [be857e88] __run_one+0xec/0x264 [test_bpf] Seguimiento de llamada: [f1b4dfe0] [00000002] 0x2 (no confiable) Volcado de instrucci\u00f3n: XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX ---[ fin del seguimiento 000000000000000 ]--- Esto es una tentativa de escribir sobre la pila. El problema se encuentra con las pruebas agregadas por el commit 38608ee7b690 (\"bpf, pruebas: Agregar caso de prueba de almacenamiento de carga para llamada de cola\") Esto sucede porque la llamada de cola se realiza a un programa BPF con una profundidad de pila diferente. En ese momento, la pila se mantiene como est\u00e1 cuando el llamador llama a la cola de su llamado. Pero al salir, el llamado restaura la pila en funci\u00f3n de sus propias propiedades. Por lo tanto, aqu\u00ed, en cada ejecuci\u00f3n, r1 se incrementa err\u00f3neamente en 32 - 16 = 16 bytes. Esto se hizo de esa manera para pasar el recuento de llamadas de cola del llamador al llamado a trav\u00e9s de la pila. Como powerpc32 no tiene una zona roja en la pila, fue necesario mantener la pila como est\u00e1 para la llamada de cola. Pero no se anticip\u00f3 que el tama\u00f1o del marco BPF podr\u00eda ser diferente. Tomemos un nuevo enfoque. Use el registro r4 para llevar el recuento de llamadas de cola durante la llamada de cola y gu\u00e1rdelo en la pila en la entrada de la funci\u00f3n si es necesario. Esto significa que el par\u00e1metro de entrada debe estar en r3, lo cual es m\u00e1s correcto ya que es un par\u00e1metro de 32 bits, por lo que la llamada de cola coincide mejor con la entrada de la funci\u00f3n BPF normal, la desventaja es que movemos ese par\u00e1metro de entrada de ida y vuelta entre r3 y r4. Esto se puede optimizar m\u00e1s adelante. Hacer eso tambi\u00e9n tiene la ventaja de maximizar las partes comunes entre las llamadas de cola y una salida de funci\u00f3n normal. Con la correcci\u00f3n, las pruebas de llamadas de cola ahora son exitosas: test_bpf: #0 Hoja de llamada de cola jited:1 53 PASS test_bpf: #1 Llamada de cola 2 jited:1 115 PASS test_bpf: #2 Llamada de cola 3 jited:1 154 PASS test_bpf: #3 Llamada de cola 4 jited:1 165 PASS test_bpf: #4 Hoja de carga/almacenamiento de llamadas de cola jited:1 101 PASS test_bpf: #5 Carga/almacenamiento de llamadas de cola jited:1 141 PASS test_bpf: #6 Ruta de error de llamada de cola, recuento m\u00e1ximo alcanzado jited:1 994 PASS test_bpf: #7 Recuento de llamadas de cola conservado en todas las llamadas de funci\u00f3n jited:1 140975 PASS test_bpf: #8 Ruta de error de llamada de cola, objetivo NULL jited:1 110 PASS test_bpf: #9 --- truncado ----"
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "baseScore": 7.8,
          "baseSeverity": "HIGH",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "HIGH",
          "integrityImpact": "HIGH",
          "availabilityImpact": "HIGH"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 5.9
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-787"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "5.13",
              "versionEndExcluding": "6.0.12",
              "matchCriteriaId": "E0C4A5C7-933F-4263-96A2-651E967D58A8"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.1:rc1:*:*:*:*:*:*",
              "matchCriteriaId": "E7E331DA-1FB0-4DEC-91AC-7DA69D461C11"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.1:rc2:*:*:*:*:*:*",
              "matchCriteriaId": "17F0B248-42CF-4AE6-A469-BB1BAE7F4705"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.1:rc3:*:*:*:*:*:*",
              "matchCriteriaId": "E2422816-0C14-4B5E-A1E6-A9D776E5C49B"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.1:rc4:*:*:*:*:*:*",
              "matchCriteriaId": "1C6E00FE-5FB9-4D20-A1A1-5A32128F9B76"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.1:rc5:*:*:*:*:*:*",
              "matchCriteriaId": "35B26BE4-43A6-4A36-A7F6-5B3F572D9186"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.1:rc6:*:*:*:*:*:*",
              "matchCriteriaId": "3FFFB0B3-930D-408A-91E2-BAE0C2715D80"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.1:rc7:*:*:*:*:*:*",
              "matchCriteriaId": "8535320E-A0DB-4277-800E-D0CE5BBA59E8"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/747a6e547240baaaf41874d27333b87b87cfd24c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/89d21e259a94f7d5582ec675aa445f5a79f347e4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    }
  ]
}