{
  "id": "CVE-2022-49006",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-10-21T20:15:12.103",
  "lastModified": "2024-10-23T15:13:25.583",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Free buffers when a used dynamic event is removed\n\nAfter 65536 dynamic events have been added and removed, the \"type\" field\nof the event then uses the first type number that is available (not\ncurrently used by other events). A type number is the identifier of the\nbinary blobs in the tracing ring buffer (known as events) to map them to\nlogic that can parse the binary blob.\n\nThe issue is that if a dynamic event (like a kprobe event) is traced and\nis in the ring buffer, and then that event is removed (because it is\ndynamic, which means it can be created and destroyed), if another dynamic\nevent is created that has the same number that new event's logic on\nparsing the binary blob will be used.\n\nTo show how this can be an issue, the following can crash the kernel:\n\n # cd /sys/kernel/tracing\n # for i in `seq 65536`; do\n     echo 'p:kprobes/foo do_sys_openat2 $arg1:u32' > kprobe_events\n # done\n\nFor every iteration of the above, the writing to the kprobe_events will\nremove the old event and create a new one (with the same format) and\nincrease the type number to the next available on until the type number\nreaches over 65535 which is the max number for the 16 bit type. After it\nreaches that number, the logic to allocate a new number simply looks for\nthe next available number. When an dynamic event is removed, that number\nis then available to be reused by the next dynamic event created. That is,\nonce the above reaches the max number, the number assigned to the event in\nthat loop will remain the same.\n\nNow that means deleting one dynamic event and created another will reuse\nthe previous events type number. This is where bad things can happen.\nAfter the above loop finishes, the kprobes/foo event which reads the\ndo_sys_openat2 function call's first parameter as an integer.\n\n # echo 1 > kprobes/foo/enable\n # cat /etc/passwd > /dev/null\n # cat trace\n             cat-2211    [005] ....  2007.849603: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n             cat-2211    [005] ....  2007.849620: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n             cat-2211    [005] ....  2007.849838: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n             cat-2211    [005] ....  2007.849880: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n # echo 0 > kprobes/foo/enable\n\nNow if we delete the kprobe and create a new one that reads a string:\n\n # echo 'p:kprobes/foo do_sys_openat2 +0($arg2):string' > kprobe_events\n\nAnd now we can the trace:\n\n # cat trace\n        sendmail-1942    [002] .....   530.136320: foo: (do_sys_openat2+0x0/0x240) arg1=             cat-2046    [004] .....   530.930817: foo: (do_sys_openat2+0x0/0x240) arg1=\"????????????????????????????????????????????????????????????????????????????????????????????????\"\n             cat-2046    [004] .....   530.930961: foo: (do_sys_openat2+0x0/0x240) arg1=\"????????????????????????????????????????????????????????????????????????????????????????????????\"\n             cat-2046    [004] .....   530.934278: foo: (do_sys_openat2+0x0/0x240) arg1=\"????????????????????????????????????????????????????????????????????????????????????????????????\"\n             cat-2046    [004] .....   530.934563: foo: (do_sys_openat2+0x0/0x240) arg1=\"???????????????????????????????????????\n---truncated---"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: rastreo: B\u00faferes libres cuando se elimina un evento din\u00e1mico usado Despu\u00e9s de que se hayan agregado y eliminado 65536 eventos din\u00e1micos, el campo \"tipo\" del evento usa el primer n\u00famero de tipo que est\u00e1 disponible (no usado actualmente por otros eventos). Un n\u00famero de tipo es el identificador de los blobs binarios en el b\u00fafer de anillo de rastreo (conocidos como eventos) para mapearlos a la l\u00f3gica que puede analizar el blob binario. El problema es que si se rastrea un evento din\u00e1mico (como un evento kprobe) y est\u00e1 en el b\u00fafer de anillo, y luego ese evento se elimina (porque es din\u00e1mico, lo que significa que se puede crear y destruir), si se crea otro evento din\u00e1mico que tenga el mismo n\u00famero, se usar\u00e1 la l\u00f3gica de ese nuevo evento al analizar el blob binario. Para mostrar c\u00f3mo esto puede ser un problema, lo siguiente puede bloquear el kernel: # cd /sys/kernel/tracing # for i in `seq 65536`; Para cada iteraci\u00f3n de lo anterior, la escritura en kprobe_events eliminar\u00e1 el evento anterior y crear\u00e1 uno nuevo (con el mismo formato) y aumentar\u00e1 el n\u00famero de tipo al siguiente disponible hasta que el n\u00famero de tipo alcance m\u00e1s de 65535, que es el n\u00famero m\u00e1ximo para el tipo de 16 bits. Despu\u00e9s de que alcanza ese n\u00famero, la l\u00f3gica para asignar un nuevo n\u00famero simplemente busca el siguiente n\u00famero disponible. Cuando se elimina un evento din\u00e1mico, ese n\u00famero est\u00e1 disponible para ser reutilizado por el pr\u00f3ximo evento din\u00e1mico creado. Es decir, una vez que lo anterior alcanza el n\u00famero m\u00e1ximo, el n\u00famero asignado al evento en ese bucle seguir\u00e1 siendo el mismo. Ahora, eso significa que eliminar un evento din\u00e1mico y crear otro reutilizar\u00e1 el n\u00famero de tipo de eventos anteriores. Aqu\u00ed es donde pueden suceder cosas malas. Despu\u00e9s de que finaliza el bucle anterior, el evento kprobes/foo que lee el primer par\u00e1metro de la llamada a la funci\u00f3n do_sys_openat2 como un entero. # echo 1 &gt; kprobes/foo/enable # cat /etc/passwd &gt; /dev/null # cat seguimiento cat-2211 [005] .... 2007.849603: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196 cat-2211 [005] .... 2007.849620: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196 cat-2211 [005] .... 2007.849838: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196 cat-2211 [005] .... 2007.849880: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196 # echo 0 &gt; kprobes/foo/enable Ahora si borramos el kprobe y creamos uno nuevo que lea una cadena: # echo 'p:kprobes/foo do_sys_openat2 +0($arg2):string' &gt; kprobe_events Y ahora podemos hacer el trace: # cat trace sendmail-1942 [002] ..... 530.136320: foo: (do_sys_openat2+0x0/0x240) arg1= cat-2046 [004] ..... 530.930817: foo: (do_sys_openat2+0x0/0x240) arg1=\"????????????????????????????????????????????? ????????????????????????????????????????????????????????????????\" cat-2046 [004] ..... 530.930961: foo: (do_sys_openat2+0x0/0x240) arg1=\"????????????????????????????????????????????? ??????????????????????????????????????????????????????????????????\" cat-2046 [004] ..... 530.934278: foo: (do_sys_openat2+0x0/0x240) arg1=\"????????????????????????????????????????????? ??????????????????????????????????????????????????\" cat-2046 [004] ..... 530.934563: foo: (do_sys_openat2+0x0/0x240) arg1=\"????????????????????????????????????????? ---truncado---"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/1603feac154ff38514e8354e3079a455eb4801e2",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/417d5ea6e735e5d88ffb6c436cf2938f3f476dd1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4313e5a613049dfc1819a6dfb5f94cf2caff9452",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/be111ebd8868d4b7c041cb3c6102e1ae27d6dc1d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/c52d0c8c4f38f7580cff61c4dfe1034c580cedfd",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}