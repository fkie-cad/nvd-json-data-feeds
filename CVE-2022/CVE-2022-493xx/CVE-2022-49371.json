{
  "id": "CVE-2022-49371",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-02-26T07:01:13.777",
  "lastModified": "2025-02-26T07:01:13.777",
  "vulnStatus": "Received",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ndriver core: fix deadlock in __device_attach\n\nIn __device_attach function, The lock holding logic is as follows:\n...\n__device_attach\ndevice_lock(dev)      // get lock dev\n  async_schedule_dev(__device_attach_async_helper, dev); // func\n    async_schedule_node\n      async_schedule_node_domain(func)\n        entry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\t/* when fail or work limit, sync to execute func, but\n\t   __device_attach_async_helper will get lock dev as\n\t   well, which will lead to A-A deadlock.  */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t  func;\n\telse\n\t  queue_work_node(node, system_unbound_wq, &entry->work)\n  device_unlock(dev)\n\nAs shown above, when it is allowed to do async probes, because of\nout of memory or work limit, async work is not allowed, to do\nsync execute instead. it will lead to A-A deadlock because of\n__device_attach_async_helper getting lock dev.\n\nTo fix the deadlock, move the async_schedule_dev outside device_lock,\nas we can see, in async_schedule_node_domain, the parameter of\nqueue_work_node is system_unbound_wq, so it can accept concurrent\noperations. which will also not change the code logic, and will\nnot lead to deadlock."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: n\u00facleo del controlador: corregir un bloqueo en __device_attach En la funci\u00f3n __device_attach, la l\u00f3gica de retenci\u00f3n de bloqueo es la siguiente:  ... __device_attach device_lock(dev) // get lock dev async_schedule_dev(__device_attach_async_helper, dev); // func async_schedule_node async_schedule_node_domain(func) entry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC); /* when fail or work limit, sync to execute func, but __device_attach_async_helper will get lock dev as well, which will lead to A-A deadlock. */ if (!entry || atomic_read(&amp;entry_count) &gt; MAX_WORK) { func; else queue_work_node(node, system_unbound_wq, &amp;entry-&gt;work) device_unlock(dev) Como se muestra arriba, cuando se permite hacer sondeos asincr\u00f3nicos, debido a falta de memoria o l\u00edmite de trabajo, no se permite el trabajo asincr\u00f3nico, para hacer la ejecuci\u00f3n sincr\u00f3nica en su lugar. conducir\u00e1 a un interbloqueo AA debido a que __device_attach_async_helper obtiene el bloqueo dev. Para solucionar el interbloqueo, mueva async_schedule_dev fuera de device_lock, como podemos ver, en async_schedule_node_domain, el par\u00e1metro de queue_work_node es system_unbound_wq, por lo que puede aceptar operaciones simult\u00e1neas. lo que tampoco cambiar\u00e1 la l\u00f3gica del c\u00f3digo y no conducir\u00e1 a un interbloqueo."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/34fdd9b7def9d2fcb71bb7b0bc4848dd7313767e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/36ee9ffca8ef56c302f2855c4a5fccf61c0c1ada",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/593b595332bd2d65e1a5c1ae7897996c157f5468",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/b232b02bf3c205b13a26dcec08e53baddd8e59ed",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d53a227bfcd5160ce1b61d9954901968a20651e7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/df6de52b80aa3b46f5ac804412355ffe2e1df93e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}