{
  "id": "CVE-2024-49885",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-10-21T18:15:11.230",
  "lastModified": "2024-11-13T14:36:33.207",
  "vulnStatus": "Analyzed",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm, slub: avoid zeroing kmalloc redzone\n\nSince commit 946fa0dbf2d8 (\"mm/slub: extend redzone check to extra\nallocated kmalloc space than requested\"), setting orig_size treats\nthe wasted space (object_size - orig_size) as a redzone. However with\ninit_on_free=1 we clear the full object->size, including the redzone.\n\nAdditionally we clear the object metadata, including the stored orig_size,\nmaking it zero, which makes check_object() treat the whole object as a\nredzone.\n\nThese issues lead to the following BUG report with \"slub_debug=FUZ\ninit_on_free=1\":\n\n[    0.000000] =============================================================================\n[    0.000000] BUG kmalloc-8 (Not tainted): kmalloc Redzone overwritten\n[    0.000000] -----------------------------------------------------------------------------\n[    0.000000]\n[    0.000000] 0xffff000010032858-0xffff00001003285f @offset=2136. First byte 0x0 instead of 0xcc\n[    0.000000] FIX kmalloc-8: Restoring kmalloc Redzone 0xffff000010032858-0xffff00001003285f=0xcc\n[    0.000000] Slab 0xfffffdffc0400c80 objects=36 used=23 fp=0xffff000010032a18 flags=0x3fffe0000000200(workingset|node=0|zone=0|lastcpupid=0x1ffff)\n[    0.000000] Object 0xffff000010032858 @offset=2136 fp=0xffff0000100328c8\n[    0.000000]\n[    0.000000] Redzone  ffff000010032850: cc cc cc cc cc cc cc cc                          ........\n[    0.000000] Object   ffff000010032858: cc cc cc cc cc cc cc cc                          ........\n[    0.000000] Redzone  ffff000010032860: cc cc cc cc cc cc cc cc                          ........\n[    0.000000] Padding  ffff0000100328b4: 00 00 00 00 00 00 00 00 00 00 00 00              ............\n[    0.000000] CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.11.0-rc3-next-20240814-00004-g61844c55c3f4 #144\n[    0.000000] Hardware name: NXP i.MX95 19X19 board (DT)\n[    0.000000] Call trace:\n[    0.000000]  dump_backtrace+0x90/0xe8\n[    0.000000]  show_stack+0x18/0x24\n[    0.000000]  dump_stack_lvl+0x74/0x8c\n[    0.000000]  dump_stack+0x18/0x24\n[    0.000000]  print_trailer+0x150/0x218\n[    0.000000]  check_object+0xe4/0x454\n[    0.000000]  free_to_partial_list+0x2f8/0x5ec\n\nTo address the issue, use orig_size to clear the used area. And restore\nthe value of orig_size after clear the remaining area.\n\nWhen CONFIG_SLUB_DEBUG not defined, (get_orig_size()' directly returns\ns->object_size. So when using memset to init the area, the size can simply\nbe orig_size, as orig_size returns object_size when CONFIG_SLUB_DEBUG not\nenabled. And orig_size can never be bigger than object_size."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm, slub: evitar poner a cero la zona roja de kmalloc Desde el commit 946fa0dbf2d8 (\"mm/slub: extender la comprobaci\u00f3n de la zona roja a espacio de kmalloc asignado adicional al solicitado\"), al establecer orig_size se trata el espacio desperdiciado (object_size - orig_size) como una zona roja. Sin embargo, con init_on_free=1 borramos todo el objeto-&gt;size, incluida la zona roja. Adem\u00e1s, borramos los metadatos del objeto, incluido el orig_size almacenado, haci\u00e9ndolo cero, lo que hace que check_object() trate todo el objeto como una zona roja. Estos problemas conducen al siguiente informe de ERROR con \"slub_debug=FUZ init_on_free=1\": [ 0.000000] ===================================================================================== [ 0.000000] ERROR kmalloc-8 (no contaminado): kmalloc Redzone sobrescrito [ 0.000000] ----------------------------------------------------------------------------- [ 0.000000] [ 0.000000] 0xffff000010032858-0xffff00001003285f @offset=2136. Primer byte 0x0 en lugar de 0xcc [ 0.000000] CORREGIR kmalloc-8: Restaurando kmalloc Redzone 0xffff000010032858-0xffff00001003285f=0xcc [ 0.000000] Losa 0xfffffdffc0400c80 objetos=36 usados=23 fp=0xffff000010032a18 indicadores=0x3fffe0000000200(workingset|node=0|zone=0|lastcpupid=0x1ffff) [ 0.000000] Objeto 0xffff000010032858 @offset=2136 fp=0xffff0000100328c8 [ 0.000000] [ 0.000000] Redzone ffff000010032850: cc cc cc cc cc cc cc cc ........ [ 0.000000] Objeto ffff000010032858: cc cc cc cc cc cc cc cc cc ........ [ 0.000000] Redzone ffff000010032860: cc cc cc cc cc cc cc cc cc ........ [ 0.000000] Relleno ffff0000100328b4: 00 00 00 00 00 00 00 00 00 00 00 00 ............ [ 0.000000] CPU: 0 UID: 0 PID: 0 Comm: intercambiador/0 No contaminado 6.11.0-rc3-next-20240814-00004-g61844c55c3f4 #144 [ 0.000000] Nombre del hardware: Placa NXP i.MX95 19X19 (DT) [ 0.000000] Rastreo de llamadas: [ 0.000000] dump_backtrace+0x90/0xe8 [ 0.000000] show_stack+0x18/0x24 [ 0.000000] dump_stack_lvl+0x74/0x8c [ 0.000000] dump_stack+0x18/0x24 [ 0.000000] print_trailer+0x150/0x218 [ 0.000000] check_object+0xe4/0x454 [ 0.000000] free_to_partial_list+0x2f8/0x5ec Para solucionar el problema, use orig_size para limpiar el \u00e1rea usada. Y restaure el valor de orig_size despu\u00e9s de limpiar el \u00e1rea restante. Cuando CONFIG_SLUB_DEBUG no est\u00e1 definido, (get_orig_size()' retorna directamente s-&gt;object_size. Entonces, cuando se usa memset para inicializar el \u00e1rea, el tama\u00f1o puede ser simplemente orig_size, ya que orig_size retorna object_size cuando CONFIG_SLUB_DEBUG no est\u00e1 habilitado. Y orig_size nunca puede ser mayor que object_size."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH",
          "baseScore": 5.5,
          "baseSeverity": "MEDIUM"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "NVD-CWE-noinfo"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.2",
              "versionEndExcluding": "6.10.14",
              "matchCriteriaId": "1337614F-3988-4131-AE51-21C855695DE3"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "versionStartIncluding": "6.11",
              "versionEndExcluding": "6.11.3",
              "matchCriteriaId": "54D9C704-D679-41A7-9C40-10A6B1E7FFE9"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/59090e479ac78ae18facd4c58eb332562a23020e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/7a2e823a19746d54052c625faecf0d2d6c52ee0a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/83f0440b2f92227fcce9898118ca7fe7e0d64b1f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    }
  ]
}