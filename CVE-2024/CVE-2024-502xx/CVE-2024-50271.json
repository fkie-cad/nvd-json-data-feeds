{
  "id": "CVE-2024-50271",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-11-19T02:16:29.180",
  "lastModified": "2024-11-19T21:57:32.967",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nsignal: restore the override_rlimit logic\n\nPrior to commit d64696905554 (\"Reimplement RLIMIT_SIGPENDING on top of\nucounts\") UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of\nsignals.  However now it's enforced unconditionally, even if\noverride_rlimit is set.  This behavior change caused production issues.  \n\nFor example, if the limit is reached and a process receives a SIGSEGV\nsignal, sigqueue_alloc fails to allocate the necessary resources for the\nsignal delivery, preventing the signal from being delivered with siginfo. \nThis prevents the process from correctly identifying the fault address and\nhandling the error.  From the user-space perspective, applications are\nunaware that the limit has been reached and that the siginfo is\neffectively 'corrupted'.  This can lead to unpredictable behavior and\ncrashes, as we observed with java applications.\n\nFix this by passing override_rlimit into inc_rlimit_get_ucounts() and skip\nthe comparison to max there if override_rlimit is set.  This effectively\nrestores the old behavior."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: se\u00f1al: restaurar la l\u00f3gica override_rlimit Antes de el commit d64696905554 (\"Reimplementar RLIMIT_SIGPENDING sobre ucounts\") UCOUNT_RLIMIT_SIGPENDING rlimit no se aplicaba para una clase de se\u00f1ales. Sin embargo, ahora se aplica de forma incondicional, incluso si se establece override_rlimit. Este cambio de comportamiento provoc\u00f3 problemas de producci\u00f3n. Por ejemplo, si se alcanza el l\u00edmite y un proceso recibe una se\u00f1al SIGSEGV, sigqueue_alloc no puede asignar los recursos necesarios para la entrega de la se\u00f1al, lo que impide que la se\u00f1al se entregue con siginfo. Esto impide que el proceso identifique correctamente la direcci\u00f3n de falla y maneje el error. Desde la perspectiva del espacio de usuario, las aplicaciones no saben que se ha alcanzado el l\u00edmite y que la siginfo est\u00e1 efectivamente \"corrupta\". Esto puede provocar un comportamiento impredecible y fallas, como observamos con las aplicaciones Java. Solucione este problema pasando override_rlimit a inc_rlimit_get_ucounts() y omita la comparaci\u00f3n con max all\u00ed si se configura override_rlimit. Esto restaura efectivamente el comportamiento anterior."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/012f4d5d25e9ef92ee129bd5aa7aa60f692681e1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/0208ea17a1e4456fbfe555f13ae5c28f3d671e40",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4877d9b2a2ebad3ae240127aaa4cb8258b145cf7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9e05e5c7ee8758141d2db7e8fea2cab34500c6ed",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}