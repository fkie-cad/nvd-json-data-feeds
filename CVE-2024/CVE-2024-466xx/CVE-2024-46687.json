{
  "id": "CVE-2024-46687",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-09-13T06:15:13.377",
  "lastModified": "2024-09-13T14:06:04.777",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix a use-after-free when hitting errors inside btrfs_submit_chunk()\n\n[BUG]\nThere is an internal report that KASAN is reporting use-after-free, with\nthe following backtrace:\n\n  BUG: KASAN: slab-use-after-free in btrfs_check_read_bio+0xa68/0xb70 [btrfs]\n  Read of size 4 at addr ffff8881117cec28 by task kworker/u16:2/45\n  CPU: 1 UID: 0 PID: 45 Comm: kworker/u16:2 Not tainted 6.11.0-rc2-next-20240805-default+ #76\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014\n  Workqueue: btrfs-endio btrfs_end_bio_work [btrfs]\n  Call Trace:\n   dump_stack_lvl+0x61/0x80\n   print_address_description.constprop.0+0x5e/0x2f0\n   print_report+0x118/0x216\n   kasan_report+0x11d/0x1f0\n   btrfs_check_read_bio+0xa68/0xb70 [btrfs]\n   process_one_work+0xce0/0x12a0\n   worker_thread+0x717/0x1250\n   kthread+0x2e3/0x3c0\n   ret_from_fork+0x2d/0x70\n   ret_from_fork_asm+0x11/0x20\n\n  Allocated by task 20917:\n   kasan_save_stack+0x37/0x60\n   kasan_save_track+0x10/0x30\n   __kasan_slab_alloc+0x7d/0x80\n   kmem_cache_alloc_noprof+0x16e/0x3e0\n   mempool_alloc_noprof+0x12e/0x310\n   bio_alloc_bioset+0x3f0/0x7a0\n   btrfs_bio_alloc+0x2e/0x50 [btrfs]\n   submit_extent_page+0x4d1/0xdb0 [btrfs]\n   btrfs_do_readpage+0x8b4/0x12a0 [btrfs]\n   btrfs_readahead+0x29a/0x430 [btrfs]\n   read_pages+0x1a7/0xc60\n   page_cache_ra_unbounded+0x2ad/0x560\n   filemap_get_pages+0x629/0xa20\n   filemap_read+0x335/0xbf0\n   vfs_read+0x790/0xcb0\n   ksys_read+0xfd/0x1d0\n   do_syscall_64+0x6d/0x140\n   entry_SYSCALL_64_after_hwframe+0x4b/0x53\n\n  Freed by task 20917:\n   kasan_save_stack+0x37/0x60\n   kasan_save_track+0x10/0x30\n   kasan_save_free_info+0x37/0x50\n   __kasan_slab_free+0x4b/0x60\n   kmem_cache_free+0x214/0x5d0\n   bio_free+0xed/0x180\n   end_bbio_data_read+0x1cc/0x580 [btrfs]\n   btrfs_submit_chunk+0x98d/0x1880 [btrfs]\n   btrfs_submit_bio+0x33/0x70 [btrfs]\n   submit_one_bio+0xd4/0x130 [btrfs]\n   submit_extent_page+0x3ea/0xdb0 [btrfs]\n   btrfs_do_readpage+0x8b4/0x12a0 [btrfs]\n   btrfs_readahead+0x29a/0x430 [btrfs]\n   read_pages+0x1a7/0xc60\n   page_cache_ra_unbounded+0x2ad/0x560\n   filemap_get_pages+0x629/0xa20\n   filemap_read+0x335/0xbf0\n   vfs_read+0x790/0xcb0\n   ksys_read+0xfd/0x1d0\n   do_syscall_64+0x6d/0x140\n   entry_SYSCALL_64_after_hwframe+0x4b/0x53\n\n[CAUSE]\nAlthough I cannot reproduce the error, the report itself is good enough\nto pin down the cause.\n\nThe call trace is the regular endio workqueue context, but the\nfree-by-task trace is showing that during btrfs_submit_chunk() we\nalready hit a critical error, and is calling btrfs_bio_end_io() to error\nout.  And the original endio function called bio_put() to free the whole\nbio.\n\nThis means a double freeing thus causing use-after-free, e.g.:\n\n1. Enter btrfs_submit_bio() with a read bio\n   The read bio length is 128K, crossing two 64K stripes.\n\n2. The first run of btrfs_submit_chunk()\n\n2.1 Call btrfs_map_block(), which returns 64K\n2.2 Call btrfs_split_bio()\n    Now there are two bios, one referring to the first 64K, the other\n    referring to the second 64K.\n2.3 The first half is submitted.\n\n3. The second run of btrfs_submit_chunk()\n\n3.1 Call btrfs_map_block(), which by somehow failed\n    Now we call btrfs_bio_end_io() to handle the error\n\n3.2 btrfs_bio_end_io() calls the original endio function\n    Which is end_bbio_data_read(), and it calls bio_put() for the\n    original bio.\n\n    Now the original bio is freed.\n\n4. The submitted first 64K bio finished\n   Now we call into btrfs_check_read_bio() and tries to advance the bio\n   iter.\n   But since the original bio (thus its iter) is already freed, we\n   trigger the above use-after free.\n\n   And even if the memory is not poisoned/corrupted, we will later call\n   the original endio function, causing a double freeing.\n\n[FIX]\nInstead of calling btrfs_bio_end_io(), call btrfs_orig_bbio_end_io(),\nwhich has the extra check on split bios and do the pr\n---truncated---"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs: se corrige un Use After Free al encontrar errores dentro de btrfs_submit_chunk() [BUG] Hay un informe interno de que KASAN informa un Use After Free, con el siguiente backtrace: BUG: KASAN: slab-use-after-free en btrfs_check_read_bio+0xa68/0xb70 [btrfs] Lectura de tama\u00f1o 4 en la direcci\u00f3n ffff8881117cec28 por la tarea kworker/u16:2/45 CPU: 1 UID: 0 PID: 45 Comm: kworker/u16:2 No contaminado 6.11.0-rc2-next-20240805-default+ #76 Nombre del hardware: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 01/04/2014 Cola de trabajo: btrfs-endio btrfs_end_bio_work [btrfs] Seguimiento de llamadas: dump_stack_lvl+0x61/0x80 print_address_description.constprop.0+0x5e/0x2f0 print_report+0x118/0x216 kasan_report+0x11d/0x1f0 btrfs_check_read_bio+0xa68/0xb70 [btrfs] process_one_work+0xce0/0x12a0 worker_thread+0x717/0x1250 kthread+0x2e3/0x3c0 ret_from_fork+0x2d/0x70 ret_from_fork_asm+0x11/0x20 Asignado por la tarea 20917: kasan_save_stack+0x37/0x60 kasan_save_track+0x10/0x30 __kasan_slab_alloc+0x7d/0x80 kmem_cache_alloc_noprof+0x16e/0x3e0 mempool_alloc_noprof+0x12e/0x310 bio_alloc_bioset+0x3f0/0x7a0 btrfs_bio_alloc+0x2e/0x50 [btrfs] enviar_extensi\u00f3n_p\u00e1gina+0x4d1/0xdb0 [btrfs] btrfs_do_readpage+0x8b4/0x12a0 [btrfs] btrfs_readahead+0x29a/0x430 [btrfs] lectura_p\u00e1ginas+0x1a7/0xc60 cach\u00e9_p\u00e1gina_sin_l\u00edmites+0x2ad/0x560 mapa_archivo_obtener_p\u00e1ginas+0x629/0xa20 mapa_archivo_leer+0x335/0xbf0 lectura_vfs+0x790/0xcb0 lectura_ksys+0xfd/0x1d0 llamada_al_sistema_64+0x6d/0x140 entrada_SYSCALL_64_despu\u00e9s_hwframe+0x4b/0x53 Liberado por la tarea 20917: pila_guardado_kasan+0x37/0x60 pista_guardado_kasan+0x10/0x30 informaci\u00f3n_libre_guardado_kasan+0x37/0x50 __kasan_slab_free+0x4b/0x60 kmem_cache_free+0x214/0x5d0 bio_free+0xed/0x180 end_bbio_data_read+0x1cc/0x580 [btrfs] btrfs_submit_chunk+0x98d/0x1880 [btrfs_submit_bio+0x33/0x7 0 [btrfs] submit_one_bio+0xd4/0x130 [btrfs] submit_extent_page+0x3ea/0xdb0 [btrfs] btrfs_do_readpage+0x8b4/0x12a0 [btrfs] btrfs_readahead+0x29a/0x430 [btrfs] read_pages+0x1a7/0xc60 page_cache_ra_unbounded+0x2ad/0x560 filemap_get_pages+0x629/0xa20 filemap_read+0x335/0xbf0 vfs_read+0x790/0xcb0 ksys_read+0xfd/0x1d0 do_syscall_64+0x6d/0x140 entry_SYSCALL_64_after_hwframe+0x4b/0x53 [CAUSA] Aunque no puedo reproducir el error, el informe en s\u00ed es lo suficientemente bueno como para determinar la causa. El seguimiento de llamadas es el contexto de la cola de trabajo de endio normal, pero el seguimiento de liberaci\u00f3n por tarea muestra que durante btrfs_submit_chunk() ya encontramos un error cr\u00edtico y est\u00e1 llamando a btrfs_bio_end_io() para que se solucione el error. Y la funci\u00f3n endio original llam\u00f3 a bio_put() para liberar todo el bio. Esto significa una doble liberaci\u00f3n, lo que provoca un Use After Free, por ejemplo: 1. Ingrese a btrfs_submit_bio() con una biograf\u00eda le\u00edda La longitud de la biograf\u00eda le\u00edda es de 128K, cruzando dos franjas de 64K. 2. La primera ejecuci\u00f3n de btrfs_submit_chunk() 2.1 Llame a btrfs_map_block(), que devuelve 64K 2.2 Llame a btrfs_split_bio() Ahora hay dos biograf\u00edas, una que hace referencia a los primeros 64K, la otra que hace referencia a los segundos 64K. 2.3 Se env\u00eda la primera mitad. 3. La segunda ejecuci\u00f3n de btrfs_submit_chunk() 3.1 Llamar a btrfs_map_block(), que de alguna manera fall\u00f3 Ahora llamamos a btrfs_bio_end_io() para manejar el error 3.2 btrfs_bio_end_io() llama a la funci\u00f3n endio original que es end_bbio_data_read(), y llama a bio_put() para el bio original. Ahora el bio original est\u00e1 liberado. 4. El primer bio de 64K enviado termin\u00f3 Ahora llamamos a btrfs_check_read_bio() e intentamos avanzar el iter del bio. Pero como el bio original (y por lo tanto su iter) ya est\u00e1 liberado, activamos el use-after free anterior. E incluso si la memoria no est\u00e1 envenenada/corrompida, luego llamaremos a la funci\u00f3n endio original, causando una doble liberaci\u00f3n. [SOLUCI\u00d3N] En lugar de llamar a btrfs_bio_end_io(), --truncada---"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/10d9d8c3512f16cad47b2ff81ec6fc4b27d8ee10",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4a3b9e1a8e6cd1a8d427a905e159de58d38941cc",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/51722b99f41f5e722ffa10b8f61e802a0e70b331",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}