{
  "id": "CVE-2024-26727",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-04-03T15:15:54.367",
  "lastModified": "2024-06-25T21:15:58.400",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: do not ASSERT() if the newly created subvolume already got read\n\n[BUG]\nThere is a syzbot crash, triggered by the ASSERT() during subvolume\ncreation:\n\n assertion failed: !anon_dev, in fs/btrfs/disk-io.c:1319\n ------------[ cut here ]------------\n kernel BUG at fs/btrfs/disk-io.c:1319!\n invalid opcode: 0000 [#1] PREEMPT SMP KASAN\n RIP: 0010:btrfs_get_root_ref.part.0+0x9aa/0xa60\n  <TASK>\n  btrfs_get_new_fs_root+0xd3/0xf0\n  create_subvol+0xd02/0x1650\n  btrfs_mksubvol+0xe95/0x12b0\n  __btrfs_ioctl_snap_create+0x2f9/0x4f0\n  btrfs_ioctl_snap_create+0x16b/0x200\n  btrfs_ioctl+0x35f0/0x5cf0\n  __x64_sys_ioctl+0x19d/0x210\n  do_syscall_64+0x3f/0xe0\n  entry_SYSCALL_64_after_hwframe+0x63/0x6b\n ---[ end trace 0000000000000000 ]---\n\n[CAUSE]\nDuring create_subvol(), after inserting root item for the newly created\nsubvolume, we would trigger btrfs_get_new_fs_root() to get the\nbtrfs_root of that subvolume.\n\nThe idea here is, we have preallocated an anonymous device number for\nthe subvolume, thus we can assign it to the new subvolume.\n\nBut there is really nothing preventing things like backref walk to read\nthe new subvolume.\nIf that happens before we call btrfs_get_new_fs_root(), the subvolume\nwould be read out, with a new anonymous device number assigned already.\n\nIn that case, we would trigger ASSERT(), as we really expect no one to\nread out that subvolume (which is not yet accessible from the fs).\nBut things like backref walk is still possible to trigger the read on\nthe subvolume.\n\nThus our assumption on the ASSERT() is not correct in the first place.\n\n[FIX]\nFix it by removing the ASSERT(), and just free the @anon_dev, reset it\nto 0, and continue.\n\nIf the subvolume tree is read out by something else, it should have\nalready get a new anon_dev assigned thus we only need to free the\npreallocated one."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: btrfs: no haga ASSERT() si el subvolumen reci\u00e9n creado ya se ley\u00f3 [ERROR] Hay un bloqueo del syzbot, provocado por ASSERT() durante la creaci\u00f3n del subvolumen: la aserci\u00f3n fall\u00f3: ! anon_dev, en fs/btrfs/disk-io.c:1319 ------------[ cortar aqu\u00ed ]------------ ERROR del kernel en fs/btrfs/disk -io.c:1319! c\u00f3digo de operaci\u00f3n no v\u00e1lido: 0000 [#1] PREEMPT SMP KASAN RIP: 0010:btrfs_get_root_ref.part.0+0x9aa/0xa60  btrfs_get_new_fs_root+0xd3/0xf0 create_subvol+0xd02/0x1650 btrfs_mksubvol+0xe95/0x12b0 __ btrfs_ioctl_snap_create+0x2f9/0x4f0 btrfs_ioctl_snap_create+0x16b /0x200 btrfs_ioctl+0x35f0/0x5cf0 __x64_sys_ioctl+0x19d/0x210 do_syscall_64+0x3f/0xe0 Entry_SYSCALL_64_after_hwframe+0x63/0x6b ---[ end trace 0000000000000000 ]--- [CA USO] Durante create_subvol(), despu\u00e9s de insertar el elemento ra\u00edz para el subvolumen reci\u00e9n creado , activar\u00edamos btrfs_get_new_fs_root() para obtener el btrfs_root de ese subvolumen. La idea aqu\u00ed es que hemos preasignado un n\u00famero de dispositivo an\u00f3nimo para el subvolumen, por lo que podemos asignarlo al nuevo subvolumen. Pero realmente no hay nada que impida que cosas como backref caminen para leer el nuevo subvolumen. Si eso sucede antes de que llamemos a btrfs_get_new_fs_root(), se leer\u00e1 el subvolumen y ya se habr\u00e1 asignado un nuevo n\u00famero de dispositivo an\u00f3nimo. En ese caso, activar\u00edamos ASSERT(), ya que realmente esperamos que nadie lea ese subvolumen (al que a\u00fan no se puede acceder desde fs). Pero a\u00fan es posible realizar cosas como el recorrido de referencia atr\u00e1s para activar la lectura en el subvolumen. Por lo tanto, nuestra suposici\u00f3n sobre ASSERT() no es correcta en primer lugar. [FIX] Arr\u00e9glelo eliminando ASSERT() y simplemente libere @anon_dev, restablezcalo a 0 y contin\u00fae. Si otra cosa lee el \u00e1rbol de subvolumen, ya deber\u00eda tener asignado un nuevo anon_dev, por lo que solo necesitamos liberar el preasignado."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/3f5d47eb163bceb1b9e613c9003bae5fefc0046f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/5a172344bfdabb46458e03708735d7b1a918c468",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/66b317a2fc45b2ef66527ee3f8fa08fb5beab88d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/833775656d447c545133a744a0ed1e189ce61430",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e03ee2fe873eb68c1f9ba5112fee70303ebf9dfb",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e31546b0f34af21738c4ceac47d662c00ee6382f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}