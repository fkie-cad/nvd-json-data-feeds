{
  "id": "CVE-2024-27405",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-17T12:15:10.500",
  "lastModified": "2024-06-25T22:15:29.580",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: ncm: Avoid dropping datagrams of properly parsed NTBs\n\nIt is observed sometimes when tethering is used over NCM with Windows 11\nas host, at some instances, the gadget_giveback has one byte appended at\nthe end of a proper NTB. When the NTB is parsed, unwrap call looks for\nany leftover bytes in SKB provided by u_ether and if there are any pending\nbytes, it treats them as a separate NTB and parses it. But in case the\nsecond NTB (as per unwrap call) is faulty/corrupt, all the datagrams that\nwere parsed properly in the first NTB and saved in rx_list are dropped.\n\nAdding a few custom traces showed the following:\n[002] d..1  7828.532866: dwc3_gadget_giveback: ep1out:\nreq 000000003868811a length 1025/16384 zsI ==> 0\n[002] d..1  7828.532867: ncm_unwrap_ntb: K: ncm_unwrap_ntb toprocess: 1025\n[002] d..1  7828.532867: ncm_unwrap_ntb: K: ncm_unwrap_ntb nth: 1751999342\n[002] d..1  7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb seq: 0xce67\n[002] d..1  7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb blk_len: 0x400\n[002] d..1  7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb ndp_len: 0x10\n[002] d..1  7828.532869: ncm_unwrap_ntb: K: Parsed NTB with 1 frames\n\nIn this case, the giveback is of 1025 bytes and block length is 1024.\nThe rest 1 byte (which is 0x00) won't be parsed resulting in drop of\nall datagrams in rx_list.\n\nSame is case with packets of size 2048:\n[002] d..1  7828.557948: dwc3_gadget_giveback: ep1out:\nreq 0000000011dfd96e length 2049/16384 zsI ==> 0\n[002] d..1  7828.557949: ncm_unwrap_ntb: K: ncm_unwrap_ntb nth: 1751999342\n[002] d..1  7828.557950: ncm_unwrap_ntb: K: ncm_unwrap_ntb blk_len: 0x800\n\nLecroy shows one byte coming in extra confirming that the byte is coming\nin from PC:\n\n Transfer 2959 - Bytes Transferred(1025)  Timestamp((18.524 843 590)\n - Transaction 8391 - Data(1025 bytes) Timestamp(18.524 843 590)\n --- Packet 4063861\n       Data(1024 bytes)\n       Duration(2.117us) Idle(14.700ns) Timestamp(18.524 843 590)\n --- Packet 4063863\n       Data(1 byte)\n       Duration(66.160ns) Time(282.000ns) Timestamp(18.524 845 722)\n\nAccording to Windows driver, no ZLP is needed if wBlockLength is non-zero,\nbecause the non-zero wBlockLength has already told the function side the\nsize of transfer to be expected. However, there are in-market NCM devices\nthat rely on ZLP as long as the wBlockLength is multiple of wMaxPacketSize.\nTo deal with such devices, it pads an extra 0 at end so the transfer is no\nlonger multiple of wMaxPacketSize."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: gadget: ncm: Evite soltar datagramas de NTB analizados correctamente. A veces se observa cuando se usa tethering a trav\u00e9s de NCM con Windows 11 como host, en algunos casos, gadget_giveback tiene un byte. adjunta al final de una NTB adecuada. Cuando se analiza el NTB, la llamada de desenvolvimiento busca los bytes sobrantes en el SKB proporcionado por u_ether y, si hay bytes pendientes, los trata como un NTB separado y lo analiza. Pero en caso de que el segundo NTB (seg\u00fan la llamada de desenvolvimiento) est\u00e9 defectuoso/da\u00f1ado, todos los datagramas que se analizaron correctamente en el primer NTB y se guardaron en rx_list se descartan. Agregar algunos seguimientos personalizados mostr\u00f3 lo siguiente: [002] d..1 7828.532866: dwc3_gadget_giveback: ep1out: req 000000003868811a length 1025/16384 zsI ==&gt; 0 [002] d..1 7828.532867: K: ncm_unwrap_ntb para procesar: 1025 [002] d..1 7828.532867: ncm_unwrap_ntb: K: ncm_unwrap_ntb nth: 1751999342 [002] d..1 7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb seq: 0xce67 [002] 7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb blk_len: 0x400 [002] d..1 7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb ndp_len: 0x10 [002] d..1 7828.532869: ncm_unwrap_ntb: K: NTB analizado con 1 fotograma En este caso, la devoluci\u00f3n es de 1025 bytes la longitud del bloque es 1024. El 1 byte restante (que es 0x00) no se analizar\u00e1, lo que provocar\u00e1 la eliminaci\u00f3n de todos los datagramas en rx_list. Lo mismo ocurre con los paquetes de tama\u00f1o 2048: [002] d..1 7828.557948: dwc3_gadget_giveback: ep1out: req 0000000011dfd96e length 2049/16384 zsI ==&gt; 0 [002] d..1 7828.557949 ncm_unwrap_ ntb: K: ncm_unwrap_ntb nth: 1751999342 [002] d..1 7828.557950: ncm_unwrap_ntb: K: ncm_unwrap_ntb blk_len: 0x800 Lecroy muestra un byte adicional entrante confirmando que el byte proviene de la PC: Transferencia 2959 - Bytes transferidos (1025) Marca de tiempo ((18.524 843 590) - Transacci\u00f3n 8391 - Datos (1025 bytes) Marca de tiempo (18.524 843 590) --- Paquete 4063861 Datos (1024 bytes) Duraci\u00f3n (2.117us) Inactivo (14.700 ns) Marca de tiempo (18.524 843 590) --- Paquete 4063863 Datos (1 byte) Duraci\u00f3n (66.160 ns) Hora (282.000 ns) Marca de tiempo (18.524 845 722) Seg\u00fan el controlador de Windows, no se necesita ZLP si wBlockLength es distinto de cero, porque wBlockLength distinto de cero ya le ha dicho al lado de la funci\u00f3n el tama\u00f1o de la transferencia. Sin embargo, hay dispositivos NCM en el mercado que dependen de ZLP siempre que wBlockLength sea m\u00faltiplo de wMaxPacketSize. Para manejar dichos dispositivos, se agrega un 0 adicional al final para que la transferencia ya no sea m\u00faltiplo de wMaxPacketSize."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/059285e04ebb273d32323fbad5431c5b94f77e48",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/2b7ec68869d50ea998908af43b643bca7e54577e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/2cb66b62a5d64ccf09b0591ab86fb085fa491fc5",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/35b604a37ec70d68b19dafd10bbacf1db505c9ca",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/57ca0e16f393bb21d69734e536e383a3a4c665fd",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/76c51146820c5dac629f21deafab0a7039bc3ccd",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a31cf46d108dabce3df80b3e5c07661e24912151",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/c7f43900bc723203d7554d299a2ce844054fab8e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}