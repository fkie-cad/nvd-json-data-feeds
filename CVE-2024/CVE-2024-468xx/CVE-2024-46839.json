{
  "id": "CVE-2024-46839",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-09-27T13:15:15.980",
  "lastModified": "2024-09-30T12:45:57.823",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nworkqueue: Improve scalability of workqueue watchdog touch\n\nOn a ~2000 CPU powerpc system, hard lockups have been observed in the\nworkqueue code when stop_machine runs (in this case due to CPU hotplug).\nThis is due to lots of CPUs spinning in multi_cpu_stop, calling\ntouch_nmi_watchdog() which ends up calling wq_watchdog_touch().\nwq_watchdog_touch() writes to the global variable wq_watchdog_touched,\nand that can find itself in the same cacheline as other important\nworkqueue data, which slows down operations to the point of lockups.\n\nIn the case of the following abridged trace, worker_pool_idr was in\nthe hot line, causing the lockups to always appear at idr_find.\n\n  watchdog: CPU 1125 self-detected hard LOCKUP @ idr_find\n  Call Trace:\n  get_work_pool\n  __queue_work\n  call_timer_fn\n  run_timer_softirq\n  __do_softirq\n  do_softirq_own_stack\n  irq_exit\n  timer_interrupt\n  decrementer_common_virt\n  * interrupt: 900 (timer) at multi_cpu_stop\n  multi_cpu_stop\n  cpu_stopper_thread\n  smpboot_thread_fn\n  kthread\n\nFix this by having wq_watchdog_touch() only write to the line if the\nlast time a touch was recorded exceeds 1/4 of the watchdog threshold."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: workqueue: Mejorar la escalabilidad del watchdog de workqueue touch En un sistema powerpc de ~2000 CPU, se han observado bloqueos duros en el c\u00f3digo de workqueue cuando se ejecuta stop_machine (en este caso debido a la conexi\u00f3n en caliente de la CPU). Esto se debe a que muchas CPU giran en multi_cpu_stop, llamando a touch_nmi_watchdog() que termina llamando a wq_watchdog_touch(). wq_watchdog_touch() escribe en la variable global wq_watchdog_touched, y esta puede encontrarse en la misma l\u00ednea de cach\u00e9 que otros datos importantes de workqueue, lo que ralentiza las operaciones hasta el punto de bloquearse. En el caso del siguiente seguimiento abreviado, worker_pool_idr estaba en la l\u00ednea directa, lo que hac\u00eda que los bloqueos siempre aparecieran en idr_find. watchdog: CPU 1125 autodetect\u00f3 BLOQUEO duro @ idr_find Seguimiento de llamadas: get_work_pool __queue_work call_timer_fn run_timer_softirq __do_softirq do_softirq_own_stack irq_exit timer_interrupt decrementer_common_virt * interrupci\u00f3n: 900 (temporizador) en multi_cpu_stop multi_cpu_stop cpu_stopper_thread smpboot_thread_fn kthread Solucione esto haciendo que wq_watchdog_touch() solo escriba en la l\u00ednea si la \u00faltima vez que se registr\u00f3 un toque excede 1/4 del umbral del watchdog."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/241bce1c757d0587721512296952e6bba69631ed",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/98f887f820c993e05a12e8aa816c80b8661d4c87",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/9d08fce64dd77f42e2361a4818dbc4b50f3c7dad",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a2abd35e7dc55bf9ed01e2b3481fa78e086d3bf4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/da5f374103a1e0881bbd35847dc57b04ac155eb0",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}