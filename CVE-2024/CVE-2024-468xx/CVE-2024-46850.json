{
  "id": "CVE-2024-46850",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-09-27T13:15:16.787",
  "lastModified": "2024-09-30T12:45:57.823",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Avoid race between dcn35_set_drr() and dc_state_destruct()\n\ndc_state_destruct() nulls the resource context of the DC state. The pipe\ncontext passed to dcn35_set_drr() is a member of this resource context.\n\nIf dc_state_destruct() is called parallel to the IRQ processing (which\ncalls dcn35_set_drr() at some point), we can end up using already nulled\nfunction callback fields of struct stream_resource.\n\nThe logic in dcn35_set_drr() already tries to avoid this, by checking tg\nagainst NULL. But if the nulling happens exactly after the NULL check and\nbefore the next access, then we get a race.\n\nAvoid this by copying tg first to a local variable, and then use this\nvariable for all the operations. This should work, as long as nobody\nfrees the resource pool where the timing generators live.\n\n(cherry picked from commit 0607a50c004798a96e62c089a4c34c220179dcb5)"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm/amd/display: Evitar la ejecuci\u00f3n entre dcn35_set_drr() y dc_state_destruct() dc_state_destruct() anula el contexto de recurso del estado del DC. El contexto de tuber\u00eda pasado a dcn35_set_drr() es un miembro de este contexto de recurso. Si se llama a dc_state_destruct() en paralelo al procesamiento de IRQ (que llama a dcn35_set_drr() en alg\u00fan momento), podemos terminar usando campos de devoluci\u00f3n de llamada de funci\u00f3n ya anulados de struct stream_resource. La l\u00f3gica en dcn35_set_drr() ya intenta evitar esto, al comprobar tg contra NULL. Pero si la anulaci\u00f3n ocurre exactamente despu\u00e9s de la comprobaci\u00f3n de NULL y antes del siguiente acceso, entonces obtenemos una ejecuci\u00f3n. Evite esto copiando tg primero a una variable local y luego use esta variable para todas las operaciones. Esto deber\u00eda funcionar, siempre y cuando nadie libere el grupo de recursos donde se encuentran los generadores de tiempo. (seleccionado de el commit 0607a50c004798a96e62c089a4c34c220179dcb5)"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/42850927656a540428e58d370b3c1599a617bac7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e835d5144f5ef78e4f8828c63e2f0d61144f283a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}