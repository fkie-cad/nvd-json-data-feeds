{
  "id": "CVE-2024-47669",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-10-09T15:15:15.590",
  "lastModified": "2024-10-10T12:51:56.987",
  "vulnStatus": "Undergoing Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix state management in error path of log writing function\n\nAfter commit a694291a6211 (\"nilfs2: separate wait function from\nnilfs_segctor_write\") was applied, the log writing function\nnilfs_segctor_do_construct() was able to issue I/O requests continuously\neven if user data blocks were split into multiple logs across segments,\nbut two potential flaws were introduced in its error handling.\n\nFirst, if nilfs_segctor_begin_construction() fails while creating the\nsecond or subsequent logs, the log writing function returns without\ncalling nilfs_segctor_abort_construction(), so the writeback flag set on\npages/folios will remain uncleared.  This causes page cache operations to\nhang waiting for the writeback flag.  For example,\ntruncate_inode_pages_final(), which is called via nilfs_evict_inode() when\nan inode is evicted from memory, will hang.\n\nSecond, the NILFS_I_COLLECTED flag set on normal inodes remain uncleared. \nAs a result, if the next log write involves checkpoint creation, that's\nfine, but if a partial log write is performed that does not, inodes with\nNILFS_I_COLLECTED set are erroneously removed from the \"sc_dirty_files\"\nlist, and their data and b-tree blocks may not be written to the device,\ncorrupting the block mapping.\n\nFix these issues by uniformly calling nilfs_segctor_abort_construction()\non failure of each step in the loop in nilfs_segctor_do_construct(),\nhaving it clean up logs and segment usages according to progress, and\ncorrecting the conditions for calling nilfs_redirty_inodes() to ensure\nthat the NILFS_I_COLLECTED flag is cleared."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nilfs2: fix state management in error path of log writing function Despu\u00e9s de aplicar el commit a694291a6211 (\"nilfs2: separate wait function from nilfs_segctor_write\"), la funci\u00f3n de escritura de registros nilfs_segctor_do_construct() pudo emitir solicitudes de E/S de forma continua incluso si los bloques de datos del usuario se divid\u00edan en varios registros en todos los segmentos, pero se introdujeron dos posibles fallos en su gesti\u00f3n de errores. En primer lugar, si nilfs_segctor_begin_construction() falla al crear el segundo registro o los siguientes, la funci\u00f3n de escritura de registros vuelve sin llamar a nilfs_segctor_abort_construction(), por lo que el indicador de escritura diferida establecido en p\u00e1ginas/folios permanecer\u00e1 sin borrar. Esto hace que las operaciones de cach\u00e9 de p\u00e1gina se cuelguen esperando el indicador de escritura diferida. Por ejemplo, truncate_inode_pages_final(), que se llama a trav\u00e9s de nilfs_evict_inode() cuando se expulsa un inodo de la memoria, se bloquear\u00e1. En segundo lugar, el indicador NILFS_I_COLLECTED establecido en inodos normales permanece sin borrar. Como resultado, si la siguiente escritura de registro implica la creaci\u00f3n de un punto de control, eso est\u00e1 bien, pero si se realiza una escritura de registro parcial que no lo hace, los inodos con NILFS_I_COLLECTED establecido se eliminan por error de la lista \"sc_dirty_files\", y sus bloques de datos y de \u00e1rbol b pueden no escribirse en el dispositivo, lo que corrompe la asignaci\u00f3n de bloques. Solucione estos problemas llamando uniformemente a nilfs_segctor_abort_construction() en caso de falla de cada paso en el bucle en nilfs_segctor_do_construct(), haciendo que limpie los registros y los usos de segmentos seg\u00fan el progreso y corrigiendo las condiciones para llamar a nilfs_redirty_inodes() para garantizar que se borre el indicador NILFS_I_COLLECTED."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/036441e8438b29111fa75008f0ce305fb4e83c0a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/0a1a961bde4351dc047ffdeb2f1311ca16a700cc",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/30562eff4a6dd35c4b5be9699ef61ad9f5f20a06",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/3e349d7191f0688fc9808ef24fd4e4b4ef5ca876",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/40a2757de2c376ef8a08d9ee9c81e77f3c750adf",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/6576dd6695f2afca3f4954029ac4a64f82ba60ab",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/74866c16ea2183f52925fa5d76061a1fe7f7737b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/efdde00d4a1ef10bb71e09ebc67823a3d3ad725b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}