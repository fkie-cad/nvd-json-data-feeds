{
  "id": "CVE-2024-46789",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-09-18T08:15:05.957",
  "lastModified": "2024-09-20T12:30:51.220",
  "vulnStatus": "Awaiting Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slub: add check for s->flags in the alloc_tagging_slab_free_hook\n\nWhen enable CONFIG_MEMCG & CONFIG_KFENCE & CONFIG_KMEMLEAK, the following\nwarning always occurs,This is because the following call stack occurred:\nmem_pool_alloc\n    kmem_cache_alloc_noprof\n        slab_alloc_node\n            kfence_alloc\n\nOnce the kfence allocation is successful,slab->obj_exts will not be empty,\nbecause it has already been assigned a value in kfence_init_pool.\n\nSince in the prepare_slab_obj_exts_hook function,we perform a check for\ns->flags & (SLAB_NO_OBJ_EXT | SLAB_NOLEAKTRACE),the alloc_tag_add function\nwill not be called as a result.Therefore,ref->ct remains NULL.\n\nHowever,when we call mem_pool_free,since obj_ext is not empty, it\neventually leads to the alloc_tag_sub scenario being invoked.  This is\nwhere the warning occurs.\n\nSo we should add corresponding checks in the alloc_tagging_slab_free_hook.\nFor __GFP_NO_OBJ_EXT case,I didn't see the specific case where it's using\nkfence,so I won't add the corresponding check in\nalloc_tagging_slab_free_hook for now.\n\n[    3.734349] ------------[ cut here ]------------\n[    3.734807] alloc_tag was not set\n[    3.735129] WARNING: CPU: 4 PID: 40 at ./include/linux/alloc_tag.h:130 kmem_cache_free+0x444/0x574\n[    3.735866] Modules linked in: autofs4\n[    3.736211] CPU: 4 UID: 0 PID: 40 Comm: ksoftirqd/4 Tainted: G        W          6.11.0-rc3-dirty #1\n[    3.736969] Tainted: [W]=WARN\n[    3.737258] Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n[    3.737875] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    3.738501] pc : kmem_cache_free+0x444/0x574\n[    3.738951] lr : kmem_cache_free+0x444/0x574\n[    3.739361] sp : ffff80008357bb60\n[    3.739693] x29: ffff80008357bb70 x28: 0000000000000000 x27: 0000000000000000\n[    3.740338] x26: ffff80008207f000 x25: ffff000b2eb2fd60 x24: ffff0000c0005700\n[    3.740982] x23: ffff8000804229e4 x22: ffff800082080000 x21: ffff800081756000\n[    3.741630] x20: fffffd7ff8253360 x19: 00000000000000a8 x18: ffffffffffffffff\n[    3.742274] x17: ffff800ab327f000 x16: ffff800083398000 x15: ffff800081756df0\n[    3.742919] x14: 0000000000000000 x13: 205d344320202020 x12: 5b5d373038343337\n[    3.743560] x11: ffff80008357b650 x10: 000000000000005d x9 : 00000000ffffffd0\n[    3.744231] x8 : 7f7f7f7f7f7f7f7f x7 : ffff80008237bad0 x6 : c0000000ffff7fff\n[    3.744907] x5 : ffff80008237ba78 x4 : ffff8000820bbad0 x3 : 0000000000000001\n[    3.745580] x2 : 68d66547c09f7800 x1 : 68d66547c09f7800 x0 : 0000000000000000\n[    3.746255] Call trace:\n[    3.746530]  kmem_cache_free+0x444/0x574\n[    3.746931]  mem_pool_free+0x44/0xf4\n[    3.747306]  free_object_rcu+0xc8/0xdc\n[    3.747693]  rcu_do_batch+0x234/0x8a4\n[    3.748075]  rcu_core+0x230/0x3e4\n[    3.748424]  rcu_core_si+0x14/0x1c\n[    3.748780]  handle_softirqs+0x134/0x378\n[    3.749189]  run_ksoftirqd+0x70/0x9c\n[    3.749560]  smpboot_thread_fn+0x148/0x22c\n[    3.749978]  kthread+0x10c/0x118\n[    3.750323]  ret_from_fork+0x10/0x20\n[    3.750696] ---[ end trace 0000000000000000 ]---"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm/slub: agregar comprobaci\u00f3n de s-&gt;flags en alloc_tagging_slab_free_hook Cuando se habilitan CONFIG_MEMCG y CONFIG_KFENCE y CONFIG_KMEMLEAK, siempre aparece la siguiente advertencia. Esto se debe a que se produjo la siguiente pila de llamadas: mem_pool_alloc kmem_cache_alloc_noprof slab_alloc_node kfence_alloc Una vez que la asignaci\u00f3n de kfence es exitosa, slab-&gt;obj_exts no estar\u00e1 vac\u00edo, porque ya se le ha asignado un valor en kfence_init_pool. Dado que en la funci\u00f3n prepare_slab_obj_exts_hook, realizamos una comprobaci\u00f3n de s-&gt;flags y (SLAB_NO_OBJ_EXT | SLAB_NOLEAKTRACE), la funci\u00f3n alloc_tag_add no se llamar\u00e1 como resultado. Por lo tanto, ref-&gt;ct permanece NULL. Sin embargo, cuando llamamos a mem_pool_free, dado que obj_ext no est\u00e1 vac\u00edo, finalmente se invoca el escenario alloc_tag_sub. Aqu\u00ed es donde se produce la advertencia. Por lo tanto, deber\u00edamos agregar las comprobaciones correspondientes en alloc_tagging_slab_free_hook. Para el caso de __GFP_NO_OBJ_EXT, no vi el caso espec\u00edfico en el que se usa kfence, por lo que no agregar\u00e9 la comprobaci\u00f3n correspondiente en alloc_tagging_slab_free_hook por ahora. [ 3.734349] ------------[ cortar aqu\u00ed ]------------ [ 3.734807] alloc_tag no se configur\u00f3 [ 3.735129] ADVERTENCIA: CPU: 4 PID: 40 en ./include/linux/alloc_tag.h:130 kmem_cache_free+0x444/0x574 [ 3.735866] M\u00f3dulos vinculados en: autofs4 [ 3.736211] CPU: 4 UID: 0 PID: 40 Comm: ksoftirqd/4 Contaminado: GW 6.11.0-rc3-dirty #1 [ 3.736969] Contaminado: [W]=WARN [ 3.737258] Nombre del hardware: QEMU KVM Virtual Machine, BIOS desconocido 2/2/2022 [ 3.737875] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 3.738501] pc : kmem_cache_free+0x444/0x574 [ 3.738951] lr : kmem_cache_free+0x444/0x574 [ 3.739361] sp : ffff80008357bb60 [ 3.739693] x29: ffff80008357bb70 x28: 0000000000000000 x27: 0000000000000000 [ 3.740338] x26: ffff80008207f000 x25: ffff000b2eb2fd60 x24: ffff0000c0005700 [ 3.740982] x23: ffff8000804229e4 x22: ffff800082080000 x21: ffff800081756000 [ 3.741630] x20: fffffd7ff8253360 x19: 00000000000000a8 x18: ffffffffffffffffff [ 3.742274] x17: ffff800ab327f000 x16: ffff800083398000 x15: ffff800081756df0 [ 3.742919] x14: 0000000000000000 x13: 205d344320202020 x12: 5b5d373038343337 [ 3.743560] x11: ffff80008357b650 x10: 000000000000005d x9 : 00000000ff ffffd0 [3.744231] x8: 7f7f7f7f7f7f7f7f x7: ffff80008237bad0 x6: c0000000ffff7fff [3.744907] x5: ffff80008237ba78 x4: ffff8000820bbad0 x3: 00000000000000001 [ 3.745580] x2 : 68d66547c09f7800 x1 : 68d66547c09f7800 x0 : 0000000000000000 [ 3.746255] Rastreo de llamadas: [ 3.746530] kmem_cache_free+0x444/0x574 [ 3.746931] mem_pool_free+0x44/0xf4 [ 3.747306] free_object_rcu+0xc8/0xdc [ 3.747693] rcu_do_batch+0x234/0x8a4 [ 3.748075] rcu_core+0x230/0x3e4 [ 3.748424] rcu_core_si+0x14/0x1c [ 3.748780] handle_softirqs+0x134/0x378 [ 3.749189] run_ksoftirqd+0x70/0x9c [ 3.749560] smpboot_thread_fn+0x148/0x22c [ 3.749978] kthread+0x10c/0x118 [ 3.750323] ret_from_fork+0x10/0x20 [ 3.750696] ---[ fin de seguimiento 0000000000000000 ]---"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/2d476c86ba4745fcbc912ce4627df4fa80caa9ad",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ab7ca09520e9c41c219a4427fe0dae24024bfe7f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}