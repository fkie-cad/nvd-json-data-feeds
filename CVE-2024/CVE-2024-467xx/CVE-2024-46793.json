{
  "id": "CVE-2024-46793",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-09-18T08:15:06.177",
  "lastModified": "2024-09-20T12:30:51.220",
  "vulnStatus": "Undergoing Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: Intel: Boards: Fix NULL pointer deref in BYT/CHT boards harder\n\nSince commit 13f58267cda3 (\"ASoC: soc.h: don't create dummy Component\nvia COMP_DUMMY()\") dummy codecs declared like this:\n\nSND_SOC_DAILINK_DEF(dummy,\n        DAILINK_COMP_ARRAY(COMP_DUMMY()));\n\nexpand to:\n\nstatic struct snd_soc_dai_link_component dummy[] = {\n};\n\nWhich means that dummy is a zero sized array and thus dais[i].codecs should\nnot be dereferenced *at all* since it points to the address of the next\nvariable stored in the data section as the \"dummy\" variable has an address\nbut no size, so even dereferencing dais[0] is already an out of bounds\narray reference.\n\nWhich means that the if (dais[i].codecs->name) check added in\ncommit 7d99a70b6595 (\"ASoC: Intel: Boards: Fix NULL pointer deref\nin BYT/CHT boards\") relies on that the part of the next variable which\nthe name member maps to just happens to be NULL.\n\nWhich apparently so far it usually is, except when it isn't\nand then it results in crashes like this one:\n\n[   28.795659] BUG: unable to handle page fault for address: 0000000000030011\n...\n[   28.795780] Call Trace:\n[   28.795787]  <TASK>\n...\n[   28.795862]  ? strcmp+0x18/0x40\n[   28.795872]  0xffffffffc150c605\n[   28.795887]  platform_probe+0x40/0xa0\n...\n[   28.795979]  ? __pfx_init_module+0x10/0x10 [snd_soc_sst_bytcr_wm5102]\n\nReally fix things this time around by checking dais.num_codecs != 0."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ASoC: Intel: Placas: Arreglar la desreferenciaci\u00f3n del puntero NULL en las placas BYT/CHT de forma m\u00e1s dif\u00edcil Desde el commit 13f58267cda3 (\"ASoC: soc.h: no crear un componente ficticio mediante COMP_DUMMY()\"), los c\u00f3decs ficticios se declaran de esta manera: SND_SOC_DAILINK_DEF(dummy, DAILINK_COMP_ARRAY(COMP_DUMMY())); expandir a: static struct snd_soc_dai_link_component dummy[] = { }; Lo que significa que dummy es una matriz de tama\u00f1o cero y, por lo tanto, dais[i].codecs no deber\u00eda desreferenciarse *en absoluto*, ya que apunta a la direcci\u00f3n de la siguiente variable almacenada en la secci\u00f3n de datos, ya que la variable \"ficticia\" tiene una direcci\u00f3n pero no un tama\u00f1o, por lo que incluso desreferenciar dais[0] ya es una referencia de matriz fuera de l\u00edmites. Esto significa que la comprobaci\u00f3n if (dais[i].codecs-&gt;name) a\u00f1adida en el commit 7d99a70b6595 (\"ASoC: Intel: Boards: Fix NULL pointer deref in BYT/CHT boards\") se basa en que la parte de la siguiente variable a la que se asigna el miembro name resulta ser NULL. Lo que aparentemente hasta ahora suele ser as\u00ed, excepto cuando no lo es y entonces da como resultado fallos como este: [ 28.795659] ERROR: no se puede gestionar la falla de p\u00e1gina para la direcci\u00f3n: 0000000000030011 ... [ 28.795780] Seguimiento de llamadas: [ 28.795787]  ... [ 28.795862] ? strcmp+0x18/0x40 [ 28.795872] 0xffffffffc150c605 [ 28.795887] platform_probe+0x40/0xa0 ... [ 28.795979] ? __pfx_init_module+0x10/0x10 [snd_soc_sst_bytcr_wm5102] Esta vez realmente solucione las cosas comprobando que dais.num_codecs != 0."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0cc65482f5b03ac2b1c240bc34665e43ea2d71bb",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/85cda5b040bda9c577b34eb72d5b2e5b7e31985c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}