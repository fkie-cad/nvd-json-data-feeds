{
  "id": "CVE-2024-26831",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-04-17T10:15:09.450",
  "lastModified": "2024-04-17T12:48:07.510",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/handshake: Fix handshake_req_destroy_test1\n\nRecently, handshake_req_destroy_test1 started failing:\n\nExpected handshake_req_destroy_test == req, but\n    handshake_req_destroy_test == 0000000000000000\n    req == 0000000060f99b40\nnot ok 11 req_destroy works\n\nThis is because \"sock_release(sock)\" was replaced with \"fput(filp)\"\nto address a memory leak. Note that sock_release() is synchronous\nbut fput() usually delays the final close and clean-up.\n\nThe delay is not consequential in the other cases that were changed\nbut handshake_req_destroy_test1 is testing that handshake_req_cancel()\nfollowed by closing the file actually does call the ->hp_destroy\nmethod. Thus the PTR_EQ test at the end has to be sure that the\nfinal close is complete before it checks the pointer.\n\nWe cannot use a completion here because if ->hp_destroy is never\ncalled (ie, there is an API bug) then the test will hang.\n\nReported by: Guenter Roeck <linux@roeck-us.net>"
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net/handshake: Fix handshake_req_destroy_test1 Recientemente, handshake_req_destroy_test1 comenz\u00f3 a fallar: Se esperaba handshake_req_destroy_test == req, pero handshake_req_destroy_test == 0000000000000000 req == 0000000060f99b40 no ok 11 req_destroy funciona Esto se debe a que \"sock_release( calcet\u00edn)\" fue reemplazado por \"fput(filp)\" para solucionar una p\u00e9rdida de memoria. Tenga en cuenta que sock_release() es sincr\u00f3nico pero fput() normalmente retrasa el cierre y la limpieza finales. El retraso no tiene consecuencias en los otros casos que se cambiaron, pero handshake_req_destroy_test1 est\u00e1 probando que handshake_req_cancel() seguido del cierre del archivo realmente llama al m\u00e9todo -&gt;hp_destroy. Por lo tanto, la prueba PTR_EQ al final debe asegurarse de que el cierre final est\u00e9 completo antes de verificar el puntero. No podemos usar una finalizaci\u00f3n aqu\u00ed porque si nunca se llama a -&gt;hp_destroy (es decir, hay un error de API), la prueba se bloquear\u00e1. Reportado por: Guenter Roeck "
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/4e1d71cabb19ec2586827adfc60d68689c68c194",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7f97805b8df6e33850e225e6bd3ebd9e246920af",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d74226e03df1bf19848f18344401f254345af912",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}