{
  "id": "CVE-2024-39486",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-07-06T10:15:03.393",
  "lastModified": "2024-07-08T15:49:22.437",
  "vulnStatus": "Undergoing Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/drm_file: Fix pid refcounting race\n\n\nfilp->pid is supposed to be a refcounted pointer; however, before this\npatch, drm_file_update_pid() only increments the refcount of a struct\npid after storing a pointer to it in filp->pid and dropping the\ndev->filelist_mutex, making the following race possible:\n\nprocess A               process B\n=========               =========\n                        begin drm_file_update_pid\n                        mutex_lock(&dev->filelist_mutex)\n                        rcu_replace_pointer(filp->pid, <pid B>, 1)\n                        mutex_unlock(&dev->filelist_mutex)\nbegin drm_file_update_pid\nmutex_lock(&dev->filelist_mutex)\nrcu_replace_pointer(filp->pid, <pid A>, 1)\nmutex_unlock(&dev->filelist_mutex)\nget_pid(<pid A>)\nsynchronize_rcu()\nput_pid(<pid B>)   *** pid B reaches refcount 0 and is freed here ***\n                        get_pid(<pid B>)   *** UAF ***\n                        synchronize_rcu()\n                        put_pid(<pid A>)\n\nAs far as I know, this race can only occur with CONFIG_PREEMPT_RCU=y\nbecause it requires RCU to detect a quiescent state in code that is not\nexplicitly calling into the scheduler.\n\nThis race leads to use-after-free of a \"struct pid\".\nIt is probably somewhat hard to hit because process A has to pass\nthrough a synchronize_rcu() operation while process B is between\nmutex_unlock() and get_pid().\n\nFix it by ensuring that by the time a pointer to the current task's pid\nis stored in the file, an extra reference to the pid has been taken.\n\nThis fix also removes the condition for synchronize_rcu(); I think\nthat optimization is unnecessary complexity, since in that case we\nwould usually have bailed out on the lockless check above."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm/drm_file: corrige la ejecuci\u00f3n de recuento de pid filp-&gt;pid se supone que es un puntero recontado; sin embargo, antes de este parche, drm_file_update_pid() solo incrementa el recuento de una estructura pid despu\u00e9s de almacenar un puntero a ella en filp-&gt;pid y eliminar dev-&gt;filelist_mutex, haciendo posible la siguiente ejecuci\u00f3n: proceso A proceso B ==== ===== ========= comenzar drm_file_update_pid mutex_lock(&amp;dev-&gt;filelist_mutex) rcu_replace_pointer(filp-&gt;pid, , 1) mutex_unlock(&amp;dev-&gt;filelist_mutex) begin drm_file_update_pid mutex_lock(&amp;dev- &gt;filelist_mutex) rcu_replace_pointer(filp-&gt;pid, , 1) mutex_unlock(&amp;dev-&gt;filelist_mutex) get_pid() synchronize_rcu() put_pid() *** pid B alcanza refcount 0 y se libera aqu\u00ed *** get_pid() *** UAF *** synchronize_rcu() put_pid() Hasta donde yo s\u00e9, esta ejecuci\u00f3n solo puede ocurrir con CONFIG_PREEMPT_RCU=y porque requiere que RCU detecte un estado inactivo en el c\u00f3digo que no llame expl\u00edcitamente al programador. Esta ejecuci\u00f3n conduce a use after free de una \"estructura pid\". Probablemente sea algo dif\u00edcil de lograr porque el proceso A tiene que pasar por una operaci\u00f3n synchronize_rcu() mientras que el proceso B est\u00e1 entre mutex_unlock() y get_pid(). Solucionelo asegur\u00e1ndose de que cuando se almacene en el archivo un puntero al pid de la tarea actual, se haya tomado una referencia adicional al pid. Esta soluci\u00f3n tambi\u00e9n elimina la condici\u00f3n de synchronize_rcu(); Creo que la optimizaci\u00f3n es una complejidad innecesaria, ya que en ese caso normalmente habr\u00edamos abandonado la verificaci\u00f3n sin bloqueo anterior."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0acce2a5c619ef1abdee783d7fea5eac78ce4844",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/16682588ead4a593cf1aebb33b36df4d1e9e4ffa",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/4f2a129b33a2054e62273edd5a051c34c08d96e9",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}